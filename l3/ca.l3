//
// Cellular automata and Conway's game of life
//

//
// cellular automata board

:caBoard v= func0
	[body :"] applyAs (| (## =>array) apply (| ## =? "*" |) |)
:caBoard @body? true @cat :ca @doc ." Create a 2D board of on/off states from a body where * means on
:caBoard @example --"+ \n
	:mypattern v= caBoard
		..**
		.**.

:=>pretty v= .( (->board : :array) 1func
	:doLine v= func1 ->s
		( s apply (| ## ? [ "*" "." ] |) foldLeft (< #1 + #2 >) ) + \n
	board apply (doLine) foldLeft (+)
:=>pretty @cat :ca @doc ." Turn a board created by :caBoard into a pretty-printed string
:=>pretty @example ." glider =>pretty

:glider v= caBoard
	.....
	..*..
	...*.
	.***.
	.....
	.....
:glider @cat :ca @doc ." A 'glider' life pattern

//
// support routines for computing new boards for a cellular automata

:countNeighbors v= func1 [ ->board ->x ->y ]
	:neighborhood v= [ [-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1] ]
	neighborhood apply (( [->i ->j] ` ( board . (x + i) . (y + j) ) ? [1 0] ` )) fold (+)
:countNeighbors @cat :ca @doc ." Count the 8 neighbors of the given cell

:getNextState v= func1 [ ->board ->x ->y ]
	:count v= countNeighbors [ board x y ]
	( board . x . y ) ? [ ( (count =? 3) |? (count =? 2) ) (count =? 3) ]
:getNextState @cat :ca @doc ." Return true/false based on whether cell should be on in the next generation

:growBoard v= func1 ->board
	:fullRow v= ( 1 .. ( board . 0 .size + 2 ) ) apply (| false |)
	:wider v= board apply (| [false] + ## + [false] |)
	[fullRow] + wider + [fullRow]
:growBoard @cat :ca @doc ." Add a border of cells that are off so no boundary checking is needed

:getNextBoard v= func1 ->board
	// add a single cell's worth of padding around the board so we don't need to check the boundary
	:board' v= growBoard board
	:columns v= 1 .. ( board' . 0 .size - 2 )
	:computeRow v= func1 ->y
		columns apply (| getNextState [ board' y ] [ ## ] |)
	( 1 .. ( board' .size - 2 ) ) apply computeRow
:getNextBoard @cat :ca @doc ." Compute the next state of an entire board
:getNextBoard @example ." getNextBoard glider

:ticks f= .( ->board 1func1 0
	board
:ticks f= .( ->board 1func1 ->n
	(getNextBoard board) ticks (n - 1)
:ticks @cat :ca @doc ." Compute the nth generation of a given board
:ticks @example ." glider ticks 5

//
// alternate cellular automata definition

:defRule v= func0
	// pull values & rules out of body
	:neighborhood       v= [ [-1 0] [0 -1] [0 1] [1 0] ]
	:default            v= false
	:transformNeighbors v= (| ## fold (+) |)
	:transition         v= (< #1 >)
	[ body :[ ] applyAs (| (## . 0) = (## . 1) |)
	//
	// private functions
	:getNextState v= func1 [ ->board ->x ->y ]
		:neighbors v= neighborhood apply (( [->i ->j] ` ( board . (x + i) . (y + j) ) ? [1 0] ` ))
		:transformed v= transformNeighbors neighbors
		transition [ ( board . x . y ) transformed ]
	:addBorder v= func1 ->board
		:fullRow v= ( 1 .. ( board . 0 .size + 2 ) ) apply (| default |)
		:wider v= board apply (| [default] + ## + [default] |)
		[fullRow] + wider + [fullRow]
	:getNextBoard v= func1 ->board
		:board' v= addBorder board
		:columns v= 1 .. ( board' . 0 .size - 2 )
		:computeRow v= func1 ->y
			columns apply (| getNextState [ board' y ] [ ## ] |)
		( 1 .. ( board' .size - 2 ) ) apply computeRow
	//
	// return a function that takes a board
	closure :getNextBoard
:defRule @body? true @cat :ca @doc --"
	Creates a function for calculating the next generation of a cellular automat board.
	Specify 1. an optional neighborhood of offsets from a cell,
	2. an optional default value to use for cells outside the board,
	3. an optional rule for transforming the neighbor cells into a state used by the
	transition rule, which defaults to adding them up,
	and 4. a rule for computing the next state.
	See .@example.
:defRule @example --"+ \n
	:myRule v= defRule
		:neighborhood       [ [-1 0] [0 -1] [0 1] [1 0] ]
		:default            false
		:transformNeighbors (| ## fold (+) |)
		:transition         (( [->state ->n] ` (n =? 2) |? (n =? 3) ` ))


:life v= defRule
	:neighborhood [ [-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1] ]
	:transition   (( [->state ->n] ` state ? [ ( (n =? 3) |? (n =? 2) ) (n =? 3) ] ` ))
:life @cat :ca @doc ." Function that applies the 'life' rule to a board
:life @example ." life glider
