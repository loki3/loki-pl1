//
// Cellular automata and Conway's game of life
//

//
// cellular automata board

:caBoard v= func0
	[body :"] applyAs (| (## =>array) apply (| ## =? :* ? [ 1 0 ] |) |)
:caBoard @body? true @cat :ca @doc ." Create a 2D board of on/off states from a body where * means on
:caBoard @example --"+ \n
	:mypattern v= caBoard
		..**
		.**.

:=>pretty v= .( (->board : :array) 1func
	:doLine v= func1 ->s
		( s apply (| ## =? 1 ? [ '*' '.' ] |) foldLeft (< #1 + #2 >) ) + \n
	board apply (doLine) foldLeft (+)
:=>pretty @cat :ca @doc ." Turn a board created by :caBoard into a pretty-printed string
:=>pretty @example ." glider =>pretty

:glider v= caBoard
	.....
	..*..
	...*.
	.***.
	.....
	.....
:glider @cat :ca @doc ." A 'glider' life pattern

//
// neighborhoods

:moore v= [ [-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1] ]
:moore @cat :ca @doc ." Cellular automata neighborhood, all eight neighboring cells

:vonNeumann v= [ [-1 0] [0 -1] [1 0] [0 1] ]
:vonNeumann @cat :ca @doc ." Cellular automata neighborhood, the four orthogonally neighboring cells

//
// support routines for computing new boards for a cellular automata

:countNeighbors v= func1 [ ->board ->x ->y ]
	:neighborhood v= [ [-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1] ]
	neighborhood apply (( [->i ->j] ` board . (x + i) . (y + j) ` )) fold (+)
:countNeighbors @cat :ca @doc ." Count the 8 neighbors of the given cell

:getNextState v= func1 [ ->board ->x ->y ]
	:count v= countNeighbors [ board x y ]
	[ (board . x . y) count ] =any? [ [1 2] [1 3] [0 3] ] ? [1 0]
:getNextState @cat :ca @doc ." Return true/false based on whether cell should be on in the next generation

:growBoard v= func1 ->board
	:fullRow v= ( 1 .. ( board . 0 .size + 2 ) ) apply (| 0 |)
	:wider v= board apply (| [0] + ## + [0] |)
	[fullRow] + wider + [fullRow]
:growBoard @cat :ca @doc ." Add a border of cells that are off so no boundary checking is needed

:getNextBoard v= func1 ->board
	// add a single cell's worth of padding around the board so we don't need to check the boundary
	:board' v= growBoard board
	:columns v= 1 .. ( board' . 0 .size - 2 )
	:computeRow v= func1 ->y
		columns apply (| getNextState [ board' y ] [ ## ] |)
	( 1 .. ( board' .size - 2 ) ) apply computeRow
:getNextBoard @cat :ca @doc ." Compute the next state of an entire board
:getNextBoard @example ." getNextBoard glider

:ticks f= .( ->board 1func1 0
	board
:ticks f= .( ->board 1func1 ->n
	(getNextBoard board) ticks (n - 1)
:ticks @cat :ca @doc ." Compute the nth generation of a given board
:ticks @example ." glider ticks 5

//
// alternate cellular automata definition

:defRule v= func0
	// pull values & rules out of body
	:neighborhood       v= [ [-1 0] [0 -1] [0 1] [1 0] ]
	:default            v= 0
	:transformNeighbors v= (| ## fold (+) |)
	:transition         v= (< #1 >)
	[ body :[ ] applyAs (| (## . 0) = (## . 1) |)
	//
	// private functions
	:computeNextState v= func1 [ ->board ->x ->y ]
		:neighbors v= neighborhood apply (( [->i ->j] ` board . (x + i) . (y + j) ` ))
		:transformed v= transformNeighbors neighbors
		transition [ ( board . x . y ) transformed ]
	:getNextBoard v= func1 ->board
		// add extra padding around board, filling with default
		:fullRow v= ( 1 .. ( board . 0 .size + 2 ) ) apply (| default |)
		:board' v= [fullRow] + ( board apply (| [default] + ## + [default] |) ) + [fullRow]
		// apply computation everywhere except padding
		:columns v= 1 .. ( board' . 0 .size - 2 )
		:computeRow v= func1 ->y
			columns apply (| computeNextState [ board' y ## ] |)
		( 1 .. ( board' .size - 2 ) ) apply computeRow
	//
	// return a function that takes a board
	closure :getNextBoard
:defRule @body? true @cat :ca @doc --"
	Creates a function for calculating the next generation of a cellular automat board.
	Specify 1. an optional neighborhood of offsets from a cell,
	2. an optional default value to use for cells outside the board,
	3. an optional rule for transforming the neighbor cells into a state used by the
	transition rule, which defaults to adding them up,
	and 4. a rule for computing the next state.
	See .@example.
:defRule @example --"+ \n
	:myRule v= defRule
		:neighborhood       [ [-1 0] [0 -1] [0 1] [1 0] ]
		:default            0
		:transformNeighbors (| ## fold (+) |)
		:transition         (( [->state ->n] ` ( (n =? 2) |? (n =? 3) ) ? [1 0] ` ))


:life v= defRule
	:neighborhood [ [-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1] ]
	:transition   (( [->state ->n] ` [state n] =any? [ [1 2] [1 3] [0 3] ] ? [1 0] ` ))
:life @cat :ca @doc ." Function that applies the 'life' rule to a board
:life @example ." life glider


//
// general apply-like methods for defining cellular automata

:apply2d f= .( (->grid : :array) 1func1 (->compute : :function)
	grid apply2d .[ (compute) .{ :default 0 :neighborhood moore
:apply2d f= .( ( ->grid : :array ) 1func1 .[ ( ->compute : :function ) .[ (->default d= 0) (->neighborhood d= moore)
	// add extra padding around grid, filling with default
	:fullRow v= ( 1 .. ( grid . 0 .size + 2 ) ) apply (| default |)
	:grid' v= [fullRow] + ( grid apply (| [default] + ## + [default] |) ) + [fullRow]
	// get neighbors
	:computeNextState v= func1 [ ->x ->y ]
		:neighbors v= neighborhood apply (( [->i ->j] ` grid' . (x + i) . (y + j) ` ))
		( grid' . x . y ) compute neighbors
	// apply computation everywhere except padding
	:columns v= 1 .. ( grid' . 0 .size - 2 )
	:computeRow v= func1 ->y
		columns apply (| computeNextState [ y ## ] |)
	( 1 .. ( grid' .size - 2 ) ) apply computeRow
:apply2d @cat :ca @doc --"
	Takes a 2d array, i.e. an array of equally sized arrays, a default value,
	and a neighborhood, and applies a 1func1 to every element, passing it the
	element and an array of each of its eight neighbors.  The function computes
	the new value for the cell.  A new 2d array is returned.
:apply2d @example ." glider apply2d (< [ #1 ( #2 fold ( + ) ) ] =any? [ [1 2] [1 3] [0 3] ] ? [1 0] >)

:lifeCell v= .( ->center 1func1 (->neighbors : :array)
	[ center ( neighbors fold ( + ) ) ] =any? [ [1 2] [1 3] [0 3] ] ? [1 0]
:lifeCell @cat :ca @doc ." Takes a cell state and neighboring states and computes new cell state
