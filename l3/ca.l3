//
// Cellular automata and Conway's game of life
//

//
// cellular automata board

:caBoard v= func0
	[body :"] applyAs (| (## =>array) apply (| ## =? "*" |) |)
:caBoard @body? true @cat :ca @doc ." Create a 2D board of on/off states from a body where * means on

:=>pretty v= .( (->board : :array) 1func
	:doLine v= func1 ->s
		( s apply (| ## ? [ "*" "." ] |) foldLeft (< #1 + #2 >) ) + \n
	board apply (doLine) foldLeft (+)
:=>pretty @cat :ca @doc ." Turn a board created by :caBoard into a pretty-printed string

:glider v= caBoard
	.....
	..*..
	...*.
	.***.
	.....
	.....
:glider @cat :ca @doc ." A 'glider' life pattern

//
// support routines for computing new boards for a cellular automata

:countNeighbors v= func1 [ ->board ->x ->y ]
	:neighborhood v= [ [-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1] ]
	neighborhood apply (( [->i ->j] ` ( board . (x + i) . (y + j) ) ? [1 0] ` )) fold (+)
:countNeighbors @cat :ca @doc ." Count the 8 neighbors of the given cell

:getNextState v= func1 [ ->board ->x ->y ]
	:count v= countNeighbors [ board x y ]
	( board . x . y ) ? [ ( (count =? 3) |? (count =? 2) ) (count =? 3) ]
:getNextState @cat :ca @doc ." Return true/false based on whether cell should be on in the next generation

:growBoard v= func1 ->board
	:fullRow v= ( 1 .. ( board . 0 .size + 2 ) ) apply (| false |)
	:wider v= board apply (| [false] + ## + [false] |)
	[fullRow] + wider + [fullRow]
:growBoard @cat :ca @doc ." Add a border of cells that are off so no boundary checking is needed

:getNextBoard v= func1 ->board
	// add a single cell's worth of padding around the board so we don't need to check the boundary
	:board' v= growBoard board
	:columns v= 1 .. ( board' . 0 .size - 2 )
	:computeRow v= func1 ->y
		columns apply (| getNextState [ board' y ] [ ## ] |)
	( 1 .. ( board' .size - 2 ) ) apply computeRow
:getNextBoard @cat :ca @doc ." Compute the next state of an entire board

:ticks f= .( ->board 1func1 0
	board
:ticks f= .( ->board 1func1 ->n
	(getNextBoard board) ticks (n - 1)
:ticks @cat :ca @doc ." Compute the nth generation of a given board

//
// alternate cellular automata definition

:defRule v= func0
	// pull neighborhood & transition rule out of body
	:neighborhood v= []
	:transition v= (< #1 >)
	:line forEachDelim [ body :[ ]
		(line . 0) = (line . 1)
	//
	// cached state
	[:maxX :maxY] v= [0 0]
	//
	// private functions
	:getCell v= func1 [ ->board ->x ->y ]
		:state v= false
		if ( (x >=? 0) &? (y >=? 0) &? (x <? maxX) &? (y <? maxY) )
			:state = board . x . y
		state
	:countNeighbors v= func1 [ ->board ->x ->y ]
		neighborhood apply (( [->i ->j] ` ( getCell [ board (x + i) (y + j) ] ) ? [1 0] ` )) fold (+)
	:getNextState v= func1 [ ->board ->x ->y ]
		transition [ ( getCell [board x y] ) ( countNeighbors [board x y] ) ]
	:getNextBoard v= func1 ->board
		[:maxX :maxY] = [ (board .size) ( (board . 0) .size ) ]
		:columns v= 0 .. ( board . 0 .size - 1 )
		:computeRow v= func1 ->y
			columns apply (| getNextState [ board y ] [ ## ] |)
		( 0 .. ( board .size - 1 ) ) apply computeRow
	//
	// return a function that takes a board
	closure :getNextBoard
:defRule @body? true @cat :ca @doc --"
	Creates a function for calculating the next generation of a cellular automat board.
	Specify the neighborhood of offsets from a cell and a rule for computing the next state.
	See .@example.
:defRule @example --"+ \n
	:myRule v= defRule
		:neighborhood [ [-1 0] [0 -1] [0 1] [1 0] ]
		:transition   (( [->state ->n] ` (n =? 2) |? (n =? 3) ` ))


:life v= defRule
	:neighborhood [ [-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1] ]
	:transition   (( [->state ->n] ` state ? [ ( (n =? 3) |? (n =? 2) ) (n =? 3) ] ` ))
:life @cat :ca @doc ." Function that applies the 'life' rule to a board
