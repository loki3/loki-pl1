//
// Help framework
//
// Provides tools for getting help on functions
//
// helpAll
// help :someFunction
// dumpMeta :someFunction
// listFunctions currentScope
//


:helpAll v= func()
	:map v= l3.getScope .{ :scope :parent
	map applyMap .(< print help #1
	""
:helpAll @cat :help @doc ." Print out information on everything defined in the given scope

:help v= func ->var
	
	// func that figures out if var is an in/post/prefix function
	:getFixType v= func()
		:details v= ."
		:builtinType v= l3.getType { :key var :builtin? true }
		if builtinType =? :function
			[ :prev  :next ]  v= [ ( var .@ :l3.func.previous ) ( var .@ :l3.func.next ) ]
			[ :prev? :next? ] v= [ ( prev !=? nil ) ( next !=? nil ) ]
			if prev? &? next?
				:details = ." (infix)
			elsif prev?
				:details = ." (postfix)
			elsif next?
				:details = ." (prefix)
			else
				:details = ." (body only)
		details
	// func that returns misc metadata
	:getOtherMeta v= func()
		:s v= ""
		[ :order :body? ] v= [ ( var .@ :l3.value.order ) ( var .@ :body? ) ]
		if order !=? nil
			:s = .( l3.stringConcat .{ :spaces 1 :array .[ :@order order
		if body? !=? nil
			:s = l3.stringConcat .{ :spaces 1 :array .[ s ." (requires body)
		s
	
	// get general info
	:result v= \n
	:type v= l3.getType { :key var }
	:cat v= var .@cat
	:fixType v= getFixType
	:otherMeta v= getOtherMeta
	:result = result + :============
	:result = result + \n + .( l3.stringConcat .{ :spaces 1 :array .[ :# var :@type type :@cat cat fixType otherMeta
	:doc v= var .@doc
	:result = result + \n + .( ( doc =? nil ) ? [ " <no docstring> " doc ]
	
	// print type specific info
	:type v= l3.getType { :key var }
	if type =? :function
		:result = result + \n + \n + .( dumpFunction var
	elsif type =? :enum
		:result = result + \n + ." type: enum
		:result = result + \n + .( dumpEnum var
	elsif type =? :delimiter
		:result = result + \n + .( dumpDelimiter var
	else
		:value v= l3.getValue .{ :key var
		:result = result + \n + .( l3.stringConcat .{ :spaces 1 :array .[ " value: " value
	result
:help @cat :help @doc ." Print out a description of the value attached to a key, e.g. details on a function


:dumpFunction v= func ->var
	
	// print info on a collection of parameters
	:getParams v= func .[ ->table ->params ->fix
		// extract metadata on a single parameter
		:getParam v= func .( ->fix ->param
			:getMeta v= func ->which
				:key v= :l3.param. + which
				if ( :t v= ( l3.getMetadata { :value param } ) . key ) =? nil
					:t = ""
				t
			:line v= [ fix param ]
			:line = line + .( getMeta :type
			:line = line + .( getMeta :default
			:line = line + .( getMeta :rest
			line
		if params !=? nil
			:type v= l3.getType .{ :value params
			if type =any? [ :map :array ]
				:param forEach params
					if :map =? l3.getType .{ :value params
						:table = table + getParam .( fix .( param . 1
					else
						:table = table + getParam .( fix param
			else
				:table = table + getParam params
		table
	
	:result v= ""
	[ :prev :next ] v= [ ( var .@ :l3.func.previous ) ( var .@ :l3.func.next ) ]
	if ( ( prev !=? nil ) |? ( next !=? nil ) )
		:table v= [ :pre/post :name :@type :@default :@rest ]
		:table = getParams .[ table prev :pre
		:table = getParams .[ table next :post
		:result = l3.formatTable { :array table :columns 5 :dashesAfterFirst? true }
	result
:dumpFunction @cat :help @doc ." Print info about a function


:dumpEnum v= func ->var
	:table v= ( l3.getValue { :key var } ) mapToArray (< [ "" #2 ] >)
	l3.formatTable2 { :arrayOfArrays table :spaces 2 }
:dumpEnum @cat :help @doc ." Print the values of an enum


:dumpDelimiter v= func ->var
	:start    v= var
	:end      v= var .@ :l3.delim.end
	:result   v= l3.stringConcat .{ :spaces 1 :array .[ :type: :delimiter start end
	
	:delimEnum v= .[ :comment :string :value :array :raw
	:type      v= delimEnum . ( var .@ :l3.delim.type )
	:result = result + \n + l3.stringConcat .{ :spaces 1 :array .[ " parse as: " type
	
	:function v= var .@ :l3.delim.function
	if ( function ) !=? nil
		:result = result + \n + ." applies the following function to the contents:
		:result = result + \n + .( help :function
	result
:dumpDelimiter @cat :help @doc ." Print the values of a delimiter


:dumpMeta v= func ->key
	:table v= [ :key :value ]
	:metadata v= l3.getMetadata { :key key }
	:pair forEach metadata
		// handle docstrings separately because they're long
		if ( pair . 0 ) =? :l3.value.doc
			:table = table + [ ( pair . 0 ) " <docstring> " ]
		else
			:table = table + pair
	l3.formatTable { :array table :columns 2 :dashesAfterFirst? true }
:dumpMeta @cat :help @doc ." Dump metadata for the given value attached to a key


:listFunctions v= func ->map
	:table v= map filterMap (< :function =? l3.getType { :key #1 :builtin? true } >) mapToArray (< #1 >)
	l3.formatTable { :array table :columns 3 }
:listFunctions @cat :help @doc ." List all the functions in the given map

:listEnums v= func ->map
	:table v= map filterMap (< :enum =? l3.getType { :key #1 } >) mapToArray (< #1 >)
	l3.formatTable { :array table :columns 3 }
:listEnums @cat :help @doc ." List all the enums in the given map

:listDelimiters v= func ->map
	:table v= map filterMap (< :delimiter =? l3.getType { :key #1 :builtin? true } >) mapToArray (< #1 >)
	l3.formatTable { :array table :columns 7 }
:listDelimiters @cat :help @doc ." List all the delimiters in the given map

:listByCat v= ( ->cat infix ->map )
	:table v= map filterMap (< ( #1 .@cat ) =? cat >) mapToArray (< #1 >)
	l3.formatTable { :array table :columns 3 }
:listByCat @cat :help @doc ." List all the values in a given category and map


:getDocs v= func()
	:scope v= l3.getScope .{ :scope :parent
	getDocsInScope scope
:getDocs @cat :help @doc ." Return all the docstrings attached to the values in the current scope

:getDocsInScope v= func ->scope
	:table v= scope filterMap (< #1 .@doc !=? nil >) mapToArray (< [ :> #1 ( #1 .@doc ) ] >)
	l3.formatTable2 { :arrayOfArrays table }
:getDocsInScope @cat :help @doc ." Return all the docstrings attached to the values in a given scope

:getFileDocs v= func ->file
	import file
	getDocsInScope currentScope
:getFileDocs @cat :help @doc ." Return all the docstrings attached to the values in a given file


:prettify v= func ->map
	:table v= map mapToArray (< [ #1 #2 ] >)
	l3.formatTable2 { :arrayOfArrays table }
:prettify @cat :help @doc ." Return a map as a simple table represented by a string
