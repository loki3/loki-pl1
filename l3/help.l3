//
// Help framework
//
// Provides tools for getting help on functions
//
// helpAll currentScope
// help :someFunction
// dumpMeta :someFunction
// listFunctions currentScope
//


:helpAll <- func ->map
	:pair forEach map
		help pair . 0
:helpAll @doc /" Print out information on everything defined in the given scope

:help <- func ->var
	
	// func that figures out if var is an in/post/prefix function
	:getFixType <- func()
		:details <- /"
		:builtinType <- l3.getType { :key var :builtin? true }
		if builtinType =? :function
			[ :prev  :next ]  <- [ ( var .@ :l3.func.previous ) ( var .@ :l3.func.next ) ]
			[ :prev? :next? ] <- [ ( prev !=? nil ) ( next !=? nil ) ]
			if prev? &? next?
				:details = /" (infix)
			elsif prev?
				:details = /" (postfix)
			elsif next?
				:details = /" (prefix)
			else
				:details = /" (body only)
		details
	// func that returns misc metadata
	:getOtherMeta <- func()
		:s <- ""
		[ :order :body? ] <- [ ( var .@ :l3.value.order ) ( var .@ :body? ) ]
		if order !=? nil
			:s = /( l3.stringConcat /{ :spaces 1 :array /[ :@order order
		if body? !=? nil
			:s = l3.stringConcat /{ :spaces 1 :array /[ s /" (requires body)
		s
	
	// print general info
	print /"
	:type <- l3.getType { :key var }
	:fixType <- getFixType
	:otherMeta <- getOtherMeta
	print :============
	print l3.stringConcat /{ :spaces 1 :array /[ :# var :@type type fixType otherMeta
	:doc <- var .@doc
	print ( doc =? nil ) ? [ " <no docstring> " doc ]
	
	// print type specific info
	:type <- l3.getType { :key var }
	if type =? :function
		print ""
		dumpFunction var
	elsif type =? :enum
		dumpEnum var
	elsif type =? :delimiter
		dumpDelimiter var
	else
		:value <- l3.getValue /{ :key var
		print l3.stringConcat /{ :spaces 1 :array /[ " value: " value
	""
:help @doc /" Print out a description of the value attached to a key, e.g. details on a function


:dumpFunction <- func ->var
	
	// print info on a collection of parameters
	:getParams <- func /[ ->table ->params ->fix
		// extract metadata on a single parameter
		:getParam <- func /( ->fix ->param
			:getMeta <- func ->which
				:key <- :l3.param. +s which
				if ( :t <- ( l3.getMetadata { :value param } ) . key ) =? nil
					:t = ""
				t
			:line <- [ fix param ]
			:line <- line +a /( getMeta :type
			:line <- line +a /( getMeta :default
			:line <- line +a /( getMeta :rest
			[ line ]
		if params !=? nil
			:type <- l3.getType /{ :value params
			if type =any? [ :map :array ]
				:param forEach params
					if :map =? l3.getType /{ :value params
						:table = table +a getParam /( fix /( param . 1
					else
						:table = table +a getParam /( fix param
			else
				:table = table +a getParam params
		table
	
	[ :prev :next ] <- [ ( var .@ :l3.func.previous ) ( var .@ :l3.func.next ) ]
	:table <- [ [ :pre/post :name :@type :@default :@rest ] ]
	:table = getParams /[ table prev :pre
	:table = getParams /[ table next :post
	print l3.formatTable { :arrayOfArrays table :dashesAfterFirst? true }
:dumpFunction @doc /" Print info about a function


:dumpEnum <- func ->var
	print /" type: enum
	:table <- [ ]
	:item forEach l3.getValue /{ :key var
		:table = table +a [ [ "" ( item . 1 ) ] ]
	print l3.formatTable { :arrayOfArrays table :spaces 2 }
:dumpEnum @doc /" Print the values of an enum


:dumpDelimiter <- func ->var
	:start    <- var .@ :l3.delim.start
	:end      <- var .@ :l3.delim.end
	print l3.stringConcat /{ :spaces 1 :array /[ :type: :delimiter start end
	
	:delimEnum <- /[ :comment :string :value :array :raw
	:type      <- delimEnum . ( var .@ :l3.delim.type )
	print l3.stringConcat /{ :spaces 1 :array /[ " parse as: " type
	
	:function <- var .@ :l3.delim.function
	if ( function ) !=? nil
		print /" applies the following function to the contents:
		help :function
:dumpDelimiter @doc /" Print the values of a delimiter


:dumpMeta <- func ->key
	:table <- [ [ :key :value ] ]
	:metadata <- l3.getMetadata { :key key }
	:pair forEach metadata
		// handle docstrings separately because they're long
		if ( pair . 0 ) =? :l3.value.doc
			:table = table +a [ [ ( pair . 0 ) " <docstring> " ] ]
		else
			:table = table +a [ pair ]
	print l3.formatTable { :arrayOfArrays table :dashesAfterFirst? true }
	""
:dumpMeta @doc /" Dump metadata for the given value attached to a key


:listByFilter <- func { :map ->map :filter? ( ->filter? @@type :function ) :perRow ( ->perRow @@default 3 ) :spaces ( ( ->spaces @@type :int ) @@default 1 ) }
	[ :table :line ] <- [ nil nil ]
	:current <- 0
	:pair forEach map
		:key <- pair . 0
		if ( filter? key )
			if current =? perRow - 1
				:table = table +a [ line ]
				:line = nil
			:current = ( current + 1 ) % perRow
			:line = line +a [ key ]
	if line !=? nil
		:table = table +a [ line ]
	if table !=? nil
		print l3.formatTable { :arrayOfArrays table :spaces spaces }
	""
:listByFilter @doc /" List all the functions that pass a filter

:listFunctions <- func ->map
	listByFilter { :map map :filter? (| :function =? l3.getType { :key ## :builtin? true } |) }
:listFunctions @doc /" List all the functions in the given map

:listEnums <- func ->map
	listByFilter { :map map :filter? (| :enum =? l3.getType { :key ## } |) }
:listEnums @doc /" List all the enums in the given map

:listDelimiters <- func ->map
	listByFilter { :map map :filter? (| :delimiter =? l3.getType { :key ## :builtin? true } |) :perRow 7 :spaces 3 }
:listDelimiters @doc /" List all the delimiters in the given map


:getDocs <- func()
	:scope <- l3.getScope /{ :scope :parent
	getDocsInScope scope
:getDocs @doc /" Return all the docstrings attached to the values in the current scope

:getDocsInScope <- func ->scope
	:table <- [ ]
	:f forEach scope
		:key <- f . 0
		if key .@doc !=? nil
			table += [ key ( key .@doc ) ]
	l3.formatTable { :arrayOfArrays table }
:getDocsInScope @doc /" Return all the docstrings attached to the values in a given scope

:getFileDocs <- func ->file
	import file
	getDocsInScope currentScope
:getFileDocs @doc /" Return all the docstrings attached to the values in a given file
