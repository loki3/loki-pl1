//
// Help framework
//
// Provides tools for getting help on functions
//
// helpAll
// help :someFunction
// dumpMeta :someFunction
// listFunctions currentScope
//


:helpAll v= func()
	:map v= l3.getScope .{ :level 1
	map applyMap .(< print help #1
	""
:helpAll @cat :help @doc ." Print out information on everything defined in the given scope

:help v= func .( ->key : :string
	// turn a map into an array useful for formatting
	:dumpMap v= func  ->map
		var :array
		:i =eachIn map
			:array = array + [ "" ( i . 0 ) ( i . 1 ) ]
		array
	// build up a description of pre or post parameters
	:dumpParams v= func .[ ->preOrPost ->overloads
		:table v= [ ]
		:table v= [ :name :type :default :rest ]
		:param =eachIn ( overloads . preOrPost )
			[ :name :type :default :rest ] apply (| :table = table + ( param . ## ) |)
		:s = :- + \s + preOrPost + \s + " parameters - " + \n
		:s = s + .( l3.formatTable { :array table :columns 4 :dashesAfterFirst? true }
		s
	
	:map v= describe key
	:s v= \n + :============ + \n
	
	// general
	:general v= map . :general
	:s = s + ( general . :name ) + \t + :type( + ( general . :type ) + :)
	if ( general . :category ) !=? nil
		:s = s + \t + :category( + ( general . :category ) + :)
	:s = s + \n
	if ( general . :documentation ) !=? nil
		:s = s + :> + ( general . :documentation ) + \n
	:s = s + \n
	
	// specific
	:table v= [ :properties " ----- " " ----- " ]
	:sansOverloads v= ( map . :specific ) filterMap (< #1 !=? :overloads >)
	:table = table + .( dumpMap sansOverloads
	:s = s + .( l3.formatTable { :array table :columns 3 } 
	
	// overloads
	:overloads v= map . :specific . :overloads
	if overloads !=? nil
		:overload =eachIn overloads
			if ( overload . :pre ) !=? [ ]
				:s = s + \n + .( dumpParams .[ :pre overload
			if ( overload . :post ) !=? [ ]
				:s = s + \n + .( dumpParams .[ :post overload
	
	s
:help @doc ." Describe the value represented by a key.


:describe v= func .( ->key : :string
	:getSpecific f= func .[ ( ->key : :string ) ( ->value : :function )
		// figure out if var is an in/post/prefix function
		:getFixType v= func()
			:details v= ."
			[ :prev  :next ]  v= [ ( key .@ :l3.func.previous ) ( key .@ :l3.func.next ) ]
			[ :prev? :next? ] v= [ ( prev !=? nil ) ( next !=? nil ) ]
			if prev? &? next?
				:details = ." infix
			elsif prev?
				:details = ." postfix
			elsif next?
				:details = ." prefix
			else
				:details = ." body only
			details
		
		// get an array of all params
		:getParams v= func ->params
			// extract metadata on a single parameter
			:getParam v= func ->param
				:getMeta v= func ->which
					:key v= :l3.pattern. + which
					if ( :t v= ( l3.getMetadata { :value param } ) . key ) =? nil
						:t = ""
					t
				:data v= { :name param }
				:data = data + { :type ( getMeta :type ) :default ( getMeta :default ) :rest ( getMeta :rest ) }
				data
			// build up list of parameter information
			:paramsList v= [ ]
			if params !=? nil
				:type v= l3.getType .{ :value params
				if type =any? [ :map :array ]
					:param =eachIn params
						if :map =? l3.getType .{ :value params
							:paramsList = paramsList + .[ .( getParam .( param . 1
						else
							:paramsList = paramsList + .[ .( getParam param
				else
					:paramsList = paramsList + .[ .( getParam params
			paramsList
		
		:map v= { }
		:map = map + { :fix ( getFixType ) }
		[ :order :body? ] v= [ ( key .@ :l3.value.order ) ( key .@ :body? ) ]
		if order =? nil
			:order = 3
		if body? =? nil
			:body? = false
		:map = map + .{ :order order :body? body?
		
		:overloads v= [ ]
		if ( key .@ :l3.func.overload? ) !=? nil
			// each of the function overloads
			:f =eachIn ( value )
				:temp v= ( f )
				:overload v= .{ :pre  .( getParams .( :temp .@ :l3.func.previous
				:overload = overload + .{ :post .( getParams .( :temp .@ :l3.func.next
				:overloads = overloads + [ overload ]
		else
			:overload v= .{ :pre  .( getParams .( key .@ :l3.func.previous
			:overload = overload + .{ :post .( getParams .( key .@ :l3.func.next
			:overloads = overloads + [ overload ]
		map + { :overloads overloads }
	
	
	:getSpecific f= func .[ ( ->key : :string ) ( ->value : :delimiter )
		:map v= .{ :start key :end ( key .@ :l3.delim.end )
		// turn the number representing the type into a string
		:delimEnum v= .[ :comment :string :value :array :raw
		:map = map + .{ :parseAs ( delimEnum . ( key .@ :l3.delim.type ) )
		// associated function, if any
		:function v= key .@ :l3.delim.function
		if ( function ) !=? nil
			:temp v= ( function )
			:map = map + { :function ( describe :temp ) }
		else
			:map = map + { :function nil }
		map
	
	:getSpecific f= func .[ ( ->key : :string ) ( ->value : :enum )
		.{ :values .( ( l3.getValue { :key key } ) mapToArray (< #2 >)
	
	:getSpecific f= func .[ ( ->key : :string ) ->value
		{ :value value }
	
	[ :general :specific ] v= [ { } { } ]
	// general properties
	:general = general + .{ :name key :type ( l3.getType { :key key } )
	:general = general + .{ :documentation ( key .@doc ) :category ( key .@cat )
	// specific properties based on type
	:specific = specific + .( getSpecific .[ key ( l3.getValue { :key key } )
	// full results
	{ :general general :specific specific }
:describe @doc ." Create a description of the value represented by a key, returning a map with details.



:dumpBody v= func ( ->name : :string )
	( l3.getFunctionBody { :key name } ) fold (< ( #1 =>str ) + ( #2 =>str ) + \n >)
:dumpBody @cat :help @doc ." Get the body of a function


:dumpMeta v= func ->key
	:table v= [ :key :value ]
	:metadata v= l3.getMetadata { :key key }
	:pair =eachIn metadata
		// handle docstrings separately because they're long
		if ( pair . 0 ) =? :l3.value.doc
			:table = table + [ ( pair . 0 ) " <docstring> " ]
		else
			:table = table + pair
	l3.formatTable { :array table :columns 2 :dashesAfterFirst? true }
:dumpMeta @cat :help @doc ." Dump metadata for the given value attached to a key


:dumpStack v= func ->scope
	:table v= [ :function :scope ]
	:i =eachIn scope
		:function v= :i .@ :l3.scope.calledFunction
		:context  v= .( i .size <? 20 ? [ i " <many values> " ]
		:table = table + [ function context ]
	l3.formatTable { :array table :columns 2 :dashesAfterFirst? true }
:dumpStack @cat :help @doc ." Dump the given stack, listing function names and variables that are defined in each scope.

:dumpCurrentStack v= func()
	dumpStack .( l3.getScope .{ :level 1
:dumpCurrentStack @cat :help @doc ." Dump the current stack, listing function names and variables that are defined in each scope.


:listFunctions v= func ->map
	:table v= map filterMap (< :function =? l3.getType { :key #1 :builtin? true } >) mapToArray (< #1 >)
	l3.formatTable { :array table :columns 3 }
:listFunctions @cat :help @doc ." List all the functions in the given map

:listEnums v= func ->map
	:table v= map filterMap (< :enum =? l3.getType { :key #1 } >) mapToArray (< #1 >)
	l3.formatTable { :array table :columns 3 }
:listEnums @cat :help @doc ." List all the enums in the given map

:listDelimiters v= func ->map
	:table v= map filterMap (< :delimiter =? l3.getType { :key #1 :builtin? true } >) mapToArray (< #1 >)
	l3.formatTable { :array table :columns 7 }
:listDelimiters @cat :help @doc ." List all the delimiters in the given map

:listByCat v= ( ->cat infix ->map )
	:table v= map filterMap (< ( #1 .@cat ) =? cat >) mapToArray (< #1 >)
	l3.formatTable { :array table :columns 3 }
:listByCat @cat :help @doc ." List all the values in a given category and map


:getDocs v= func()
	:scope v= l3.getScope .{ :level 1
	getDocsInScope scope
:getDocs @cat :help @doc ." Return all the docstrings attached to the values in the current scope

:getDocsInScope v= func ->scope
	:table v= scope filterMap (< #1 .@doc !=? nil >) mapToArray (< [ :> #1 ( #1 .@doc ) ] >)
	l3.formatTable2 { :arrayOfArrays table }
:getDocsInScope @cat :help @doc ." Return all the docstrings attached to the values in a given scope

:getFileDocs v= func ->file
	import file
	getDocsInScope currentScope
:getFileDocs @cat :help @doc ." Return all the docstrings attached to the values in a given file


:prettify v= func ->map
	:table v= map mapToArray (< [ #1 #2 ] >)
	l3.formatTable2 { :arrayOfArrays table }
:prettify @cat :help @doc ." Return a map as a simple table represented by a string
