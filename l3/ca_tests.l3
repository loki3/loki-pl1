//
// unit tests for ca.l3
//

:caBoard @unittest func0
	:b v= caBoard
		.*.
		*..
	[ 0 1 0 ] assert=? b . 0
	[ 1 0 0 ] assert=? b . 1

:=>pretty @unittest func0
	:b v= [ [1 0] [0 1] ]
	( "*." + \n + ".*" + \n ) assert=? ( b =>pretty )

:glider @unittest noTestNeeded

:countNeighbors @unittest func0
	:b v= [ [0 0 0 0] [0 1 0 0] [0 0 1 0] [0 0 0 0] ]
	1 assert=? countNeighbors [b 1 1]
	2 assert=? countNeighbors [b 1 2]
	2 assert=? countNeighbors [b 2 1]
	1 assert=? countNeighbors [b 2 2]
	true

:getNextState @unittest func0
	// **.*
	// .***
	:padding v= [0 0 0 0 0 0]
	:main v= [ [0 1 1 0 1 0] [0 0 1 1 1 0] ]
	:b v= [padding] + main + [padding]
	// survives with 2 neighbors
	1 assert=? getNextState [b 1 1]
	// survives with 3 neighbors
	1 assert=? getNextState [b 1 2]
	// no birth with 5 neighbors
	0 assert=? getNextState [b 1 3]
	// survives with 2 neighbors
	1 assert=? getNextState [b 1 4]
	// born from 3 neighbors
	1 assert=? getNextState [b 2 1]
	// survives with 3 neighbors
	1 assert=? getNextState [b 2 2]
	// dies from 4 neighbors
	0 assert=? getNextState [b 2 3]
	// survives with 2 neighbors
	1 assert=? getNextState [b 2 4]

:growBoard @unittest func0
	:a v= growBoard [ [1 2 3] [4 5 6] ]
	[ [0 0 0 0 0] [0 1 2 3 0] [0 4 5 6 0] [0 0 0 0 0] ] assert=? a

:getNextBoard @unittest func0
	// **.*
	// .***
	:b' v= getNextBoard [ [ 1 1 0 1 ] [ 0 1 1 1 ] ]
	[ 1 1 0 1 ] assert=? b' . 0
	[ 1 1 0 1 ] assert=? b' . 1

:ticks @unittest func0
	// ...
	// ***
	// ...
	:b v= [ [ 0 0 0 ] [ 1 1 1 ] [ 0 0 0 ] ]
	:b' v= [ [ 0 1 0 ] [ 0 1 0 ] [ 0 1 0 ] ]
	b' assert=? ( b ticks 1 )
	b  assert=? ( b ticks 2 )

:defRule @unittest func0
	:rule v= defRule
		:neighborhood [ [-1 0] [0 -1] [0 1] [1 0] ]
		:transition   (( [->state ->n] ` n =any? [2 3] ? [1 0] ` ))
	:input v= caBoard
		.*..*
		**.*.
	:expected v= caBoard
		*..*.
		.**.*
	:actual v= rule input
	expected assert=? actual

:life @unittest func0
	:input v= caBoard
		**.*
		.***
	:expected v= caBoard
		**.*
		**.*
	:actual v= life input
	expected assert=? actual
