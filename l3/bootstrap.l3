l3.createEvalDelimiter :()
l3.createArrayDelimiter :[]
l3.setValue ( l3.createMap [ :key :{ :value ( l3.createDelimiter l3.createMap [ :start :{  :end :} :type :asArray :function l3.createMap ] ) ] )
l3.setValue { :key :// :value ( l3.createDelimiter { :start ://  :end : :type :asComment } ) }

// the first lines created () as the value delimiter,
// [] as the array delimiter, {} as the map delimeter,
// and // as the remainder-of-line comment delimiter

// raw delimiter
l3.setValue { :key :` :value ( l3.createDelimiter { :start :`  :end :` :type :asRaw } ) }

// assignment
l3.setValue { :key := :value ( l3.createFunction { :pre ->key :post ->value :order 1 :body [ ` l3.setValue { :key key :value value :scope :parent } ` ] } ) }

// remainder of line is a value (like Haskell's $)
:/( = ( l3.createDelimiter { :start :/(  :end : :type :asValue } )

// remainder of line is an array
:/[ = /( l3.createDelimiter { :start :/[  :end : :type :asArray }

// remainder of line is a map
:/{ = /( l3.createDelimiter { :start :/{  :end : :type :asArray :function l3.createMap }

// range comment delimiter
:/* = /( l3.createDelimiter /{ :start :/*  :end :*/ :type :asComment

// string delimiter
:" = /( l3.createDelimiter /{ :start :"  :end :" :type :asString

// remainder of line is a string
:/" = /( l3.createDelimiter /{ :start :/"  :end : :type :asString


//
// function definitions:

// a function which creates a prefix function
:func = l3.createFunction { :post ->pattern }
	l3.createFunction { :post pattern }

// a function which creates an infix function
:infix = /( l3.createFunction { :pre ->pattern1 :post ->pattern2 }
	l3.createFunction { :pre pattern1 :post pattern2 }

// a function which creates a postfix function
:postfix = /( l3.createFunction { :pre ->pattern }
	l3.createFunction { :pre pattern }


//
// get & set

// member access using the . infix
:. = /( ->a infix ->b
	l3.getValue { :object a :key b }

// modify a value's metadata
:@ = /( ->object infix [ ->key ->value ]
	l3.setValue { :map ( l3.getMetadata { :key object :writable? true } ) :key key :value value }

// get a particular piece of metadata attached to a value
:.@ = /( ->object infix ->key
	l3.getValue { :object ( l3.getMetadata { :key object } ) :key key }

// set the doc string on a value
:@doc = /( ->object infix ->docString
	object @ [ :l3.value.doc docString ]

// get the doc string attached to a value
:.@doc = /( ->object postfix
	l3.getValue { :object ( l3.getMetadata { :key object } ) :key :l3.value.doc }


//
// add documentation to functions that have been previously definied

:=		@doc	" Assign a value to a key "
:func	@doc	" Define a function that takes parameters after the function name "
:infix	@doc	" Define a function that takes parameters before and after the function name "
:postfix @doc	" Define a function that takes parameters before the function name "
:.		@doc	" Access the member of a map by key or array by index "
:@		@doc	" Modify a value's metadata "
:@doc	@doc	" Add documentation to a value "


//
// math

:+ = ( ->a infix ->b )
	l3.add [ a b ]
:+ @doc " Add two numbers "

:- = ( ->a infix ->b )
	l3.subtract [ a b ]
:- @doc " Subtract one number from another "

:* = ( ->a infix ->b )
	l3.multiply [ a b ]
:* @doc " Multiply two numbers "

:/ = ( ->a infix ->b )
	l3.divide [ a b ]
:/ @doc " Divide the first number by the second number "

:sqrt = func ->a
	l3.sqrt a
:sqrt @doc " Compute the square root of a number "
