l3.createEvalDelimiter :()
l3.createArrayDelimiter :[]
l3.setValue ( l3.createMap [ :key :{ :value ( l3.createDelimiter l3.createMap [ :end :} :type :asArray :function l3.createMap ] ) ] )
l3.setValue { :key :// :value ( l3.createDelimiter { :type :asComment } ) }

// the first lines created () as the value delimiter,
// [] as the array delimiter, {} as the map delimeter,
// and // as the remainder-of-line comment delimiter

// raw delimiter
l3.setValue { :key :` :value ( l3.createDelimiter { :end :` :type :asRaw } ) }

// create a new variable and assign a value
l3.setValue { :key :v= :value ( l3.createFunction { :pre ->key :post ->value :order 5 :body [ ` l3.setValue { :key key :value value :scope :parent :create? true } ` ] } ) }

// same as v= but allows for function overloading
l3.setValue { :key :f= :value ( l3.createFunction { :pre ->key :post ->value :order 5 :body [ ` l3.setValue { :key key :value value :scope :parent :create? true :overload? true } ` ] } ) }

// create a new variable with a value of nil, doesn't overwrite if it already exists
l3.setValue { :key :var :value ( l3.createFunction { :post ->name :order 2 :body [ ` l3.setValue { :key name :value nil :scope :parent :create? true :initOnly? true } ` ` name ` ] } ) }

// assignment
l3.setValue { :key := :value ( l3.createFunction { :pre ->key :post ->value :order 6 :body [ ` l3.setValue { :key key :value value :scope :parent :create? false } ` ] } ) }

// remainder of line is a value
:.( v= ( l3.createDelimiter { :type :asValue } )

// remainder of line is an array
:.[ v= .( l3.createDelimiter { :type :asArray }

// remainder of line is a map
:.{ v= .( l3.createDelimiter { :type :asArray :function l3.createMap }

// remainder of line is raw
:.` v= .( l3.createDelimiter .{ :type :asRaw

// range comment delimiter
:/* v= .( l3.createDelimiter .{ :end :*/ :type :asComment

// string delimiter
:" v= .( l3.createDelimiter .{ :end :" :type :asString
:' v= .( l3.createDelimiter .{ :end :' :type :asString

// remainder of line is a string
:." v= .( l3.createDelimiter .{ :type :asString
:.' v= .( l3.createDelimiter .{ :type :asString


//
// function definitions:

// a function which creates a prefix function
:func v= l3.createFunction { :post ->pattern }
	l3.createFunction { :post pattern }

// a function which creates an infix function
:infix v= .( l3.createFunction { :pre ->pattern1 :post ->pattern2 }
	l3.createFunction { :pre pattern1 :post pattern2 }

// a function which creates a postfix function
:postfix v= .( l3.createFunction { :pre ->pattern }
	l3.createFunction { :pre pattern }

// a function with no parameters which may decide to execute its body
:func() v= l3.createFunction { }
	l3.createFunction { }


//
// get & set

// member access using the . infix
:. v= .( ->a infix ->b
	l3.getValue .{ :object a :key b

// modify a value's metadata
:@ v= .( ->object infix [ ->key ->value ]
	l3.setValue .{ :map ( l3.getMetadata { :key object :writable? true } ) :key key :value value
	object

// get all the metadata attached to a value
:.@@ v= .( ->object postfix
	l3.getMetadata { :key object }

// get a particular piece of metadata attached to a value
:.@ v= .( ->object infix ->key
	l3.getValue .{ :object ( l3.getMetadata { :key object } ) :key key

// set the doc string on a value
:@doc v= .( ->object infix ->docString
	object @ .[ :l3.value.doc docString

:.@doc v= .( ->object postfix
	:metadata v= l3.getMetadata { :key object }
	:doc v= nil
	if metadata !=? nil
		:doc = l3.getValue .{ :object metadata :key :l3.value.doc
	doc
:.@doc	@doc ." Get the documentation attached to a value

:@cat v= .( ->object infix ->catString
	object @ .[ :l3.value.cat catString
:@cat @cat :metadata @doc ." Set the category string on a value

:.@cat v= .( ->object postfix
	:metadata v= l3.getMetadata { :key object }
	:cat v= nil
	if metadata !=? nil
		:cat = l3.getValue .{ :object metadata :key :l3.value.cat
	cat
:.@cat @cat :metadata @doc ." Get the category attached to a value

:@order v= .( ->object infix ->order
	object @ .[ :l3.value.order order
:@order @cat :metadata @doc ." Add evaluation order to a value

:@body? v= .( ->object infix ->body?
	object @ .[ :body? body?
:@body? @cat :metadata @doc ." Declare that a function requires a body

:@type v= .( ->object infix ->type
	object @ .[ :l3.value.type type
:@type @cat :metadata @doc ." Restrict a key to a specific type

:@iterator v= .( ->object postfix
	object @ .[ :l3.func.createScope? false
	object @type :iterator
:@iterator @cat :metadata @doc ." Add metadata to a function so it can be used as an iterator

:@@ v= .( ->object infix [ ->key ->value ]
	l3.setValue .{ :map ( l3.getMetadata { :value object :writable? true } ) :key key :value value
	object
:@@ @cat :metadata @doc ." Set metadata on a value, e.g. a parameter

:@@type v= .( ->object infix ->type
	object @@ .[ :l3.param.type type
:@@type @cat :metadata @doc ." Restrict a parameter to a specific type

:@@default v= .( ->object infix ->default
	object @@ .[ :l3.param.default default
:@@default @cat :metadata @doc ." Set the default value for a parameter if not present

:@@rest v= .( ->object postfix
	object @@ .[ :l3.param.rest true
:@@rest @cat :metadata @doc ." Associated parameter will be filled with the remainder of the parameter values

:copy v= func ->value
	l3.copy .{ :value value
:copy @cat :create @doc ." Make a copy of a value

:currentScope v= func()
	l3.getScope .{ :scope :parent
:currentScope @cat :scope @doc ." Get a map representing the current scope

:setScopeName v= func ->name
	l3.getScope { :scope :parent } @@ .[ :l3.scope.name name
:setScopeName @cat :scope @doc ." Assign a name to the current scope.  Useful for popping back to this scope.

:i= v= .( ->pattern infix ->value
	l3.setValue { :key pattern :value value :scope :parent :create? true :initOnly? true }
:i= @order 5
:i= @cat :assign @doc ." If variables don't exist, initialize them, otherwise leave them alone.


// bump up precedence of .
:. @order 2


//
// add documentation to functions that have been previously definied

:(		@cat :delimiter @doc ." Delimiter around code that is evaluated to a single value
:[		@cat :delimiter @doc ." Delimiter around values in an array
:{		@cat :delimiter @doc ." Delimiter around key/value pairs in a map
://		@cat :delimiter @doc ." Remainder of line is ignored
:`		@cat :delimiter @doc ." Delimiter around code that may be evaluated at a later time
:.(		@cat :delimiter @doc ." Remainder of line is evaluated to a single value
:.[		@cat :delimiter @doc ." Remainder of line is values in an array
:.{		@cat :delimiter @doc ." Remainder of line is key/value pairs in a map
:.`		@cat :delimiter @doc ." Remainder of line may be evaluated at a later time
:/*		@cat :delimiter @doc ." Everything with delimiters is ignored
:"		@cat :delimiter @doc ." Delimiter around a string
:'		@cat :delimiter @doc ." Delimiter around a string
:."		@cat :delimiter @doc ." Remainder of line is a string
:.'		@cat :delimiter @doc ." Remainder of line is a string
:v=		@cat :assign    @doc ." Create a new key/value pair in the current scope
:f=		@cat :assign    @doc ." Create a new key/value pair in the current scope, like v= but functions can be overloaded
:=		@cat :assign    @doc ." Assign a value to a key
:var	@cat :assign    @doc ." Create a new variable in the current scope
:func	@cat :function  @doc ." Define a function that takes parameters after the function name
:infix	@cat :function  @doc ." Define a function that takes parameters before and after the function name
:postfix @cat :function @doc ." Define a function that takes parameters before the function name
:func()	@cat :function  @doc ." Define a function that takes no parameters
:.		@cat :access    @doc ." Access the member of a map by key or array by index
:@		@cat :metadata  @doc ." Modify a value's metadata
:.@		@cat :metadata  @doc ." Get a value's metadata
:.@@	@cat :metadata  @doc ." Get all of a value's metadata
:@doc	@cat :metadata  @doc ." Add documentation to a value


//
// more function definitions


// definitions that take a pattern and one or more lines of code

:lambda v= func [ ->pattern ->line1 ( ->more @@rest ) ]
	l3.createFunction { :post pattern :body ( [ line1 ] + more ) }
:lambda	@cat :function @doc ." Creates a function where the first param is the pattern and the rest are lines in the function body, e.g. lambda [ :x ` 2 + x ` ]

:(( v= .( l3.createDelimiter .{ :end :)) :type :asArray :function lambda
:((		@cat :function @doc ." Creates a function where the first param is the pattern and the rest are lines in the function body, e.g. (( :x ` 2 + x ` ))

:.(( v= .( l3.createDelimiter .{ :type :asArray :function lambda
:.((	@cat :function @doc ." Remainder of line is a function where the first param is the pattern and the rest are lines in the function body, e.g. (( :x ` 2 + x ` ))


// definitions that create a prefix function, assume parameter is called ## and takes a single line of code

:lambda1 v= func ->line
	l3.createFunction { :post ->## :body [ line ] }
:lambda1	@cat :function @doc ." Creates a single line prefix function, assuming parameter is called ##, e.g. lambda1 ` 2 + ## `

:(| v= .( l3.createDelimiter .{ :end :|) :type :asRaw :function lambda1
:(|		@cat :function @doc ." Create a single line prefix function, assuming parameter is called ##, e.g. (| 2 + ## |)

:.(| v= .( l3.createDelimiter .{ :type :asRaw :function lambda1
:.(|	@cat :function @doc ." Create a single line prefix function, assuming parameter is called ##, e.g. .(| 2 + ##


// definitions that create an infix function, assume parameters are called #1 and #2 and takes a single line of code

:lambda2 v= func ->line
	l3.createFunction { :pre ->#1 :post ->#2 :body [ line ] }
:lambda2	@cat :function @doc ." Create a single line infix function, assuming parameters are called #1 and #2, e.g. lambda2 ` #1 + #2 `

:(< v= .( l3.createDelimiter .{ :end :>) :type :asRaw :function lambda2
:(<		@cat :function @doc ." Create a single line infix function, assuming parameters are called #1 and #2, e.g. (< #1 + #2 >)

:.(< v= .( l3.createDelimiter .{ :type :asRaw :function lambda2
:.(<	@cat :function @doc ." Create a single line infix function, assuming parameters are called #1 and #2, e.g. .(< #1 + #2


//
// types

:_ v= nil
:_ @doc ." Represents nil.  Useful in pattern matching for ignoring a value.


//
// logic

:&? v= .(< l3.and? [ #1 #2 ]
:&? @order 5
:&? @cat :logic @doc ." Return true if both values are true

:|? v= .(< l3.or? [ #1 #2 ]
:|? @order 5
:|? @cat :logic @doc ." Return true if either value is true

:!? v= .(| l3.not? ##
:!? @cat :logic @doc ." Returns true if value is false or false if value is true

:=? v= .(< l3.equal? [ #1 #2 ]
:=? @order 4
:=? @cat :logic @doc ." Return true if two values are equal

:!=? v= .(< !? l3.equal? [ #1 #2 ]
:!=? @order 4
:!=? @cat :logic @doc ." Return true if two values are not equal

:=any? v= .( ->value infix ( ->array @@type :array )
	l3.anyEqual? [ value array ]
:=any? @cat :logic @doc ." Return true if value is equal to anything in array


//
// arrays

:.. v= .( ( ->start @@type :number ) infix ( ->end @@type :number )
	l3.createRange { :start start :end end }
:.. @cat :array @doc ." Creates an array starting with one value and ending with another

:+ f= .( ->value1 infix ( ->array2 @@type :array )
	l3.combine .[ value1 array2
:+ f= .( ( ->array1 @@type :array ) infix ->value2
	l3.combine .[ array1 value2
:+ @cat :array @doc ." Combine two arrays

:+= v= .( ( ->array @@type :array ) infix ->value
	l3.addToArray .{ :array array :value value
:+= @order 6
:+= @cat :array @doc ." Add a value to an array

:.size v= .( ->value postfix
	l3.getCount value
:.size @cat :array @doc ." Return the number of elements in a collection.

:apply v= .( ( ->array @@type :array ) infix ( ->function @@type :function )
	l3.arrayToArray { :array array :transform function }
:apply @cat :array @doc ." Apply function to every element of a collection.  Functions for arrays take a single value.  Functions for maps are infix.  Returns the new collection.

:foldLeft v= .( ( ->array @@type :array ) infix ( ->function @@type :function )
	l3.foldLeft { :array array :function function }
:foldLeft @cat :array @doc ." ((a[0] function a[1]) function a[2]) etc.  Returns a single value.

:fold v= .( foldLeft

:foldRight v= .( ( ->array @@type :array ) infix ( ->function @@type :function )
	l3.foldRight { :array array :function function }
:foldRight @cat :array @doc ." (a[0] function (a[1] function a[2])) etc.  Returns a single value.

:filter v= .( ( ->array @@type :array ) infix ( ->function @@type :function )
	l3.arrayToArray { :array array :filter? function }
:filter @cat :array @doc ." Returns an array consisting of every member for which function returns true

:makeArray v= func()
	:array v= [ ]
	:line forEach body
		:array = array + [ line ]
	array
:makeArray @cat :array @doc ." Make an array where every line in the body is evaluated and becomes an element in the array
:makeArray @body? true


//
// maps

:+ f= .( ->value1 infix ( ->map2 @@type :map )
	l3.combine .[ value1 map2
:+ f= .( ( ->map1 @@type :map ) infix ->value2
	l3.combine .[ map1 value2
:+ @cat :map @doc ." Combine two maps

:makeMap v= func()
	:map v= { }
	:submap forEachDelim [ body :{ ]
		:map = map + submap
	map
:makeMap @cat :map @doc ." Make a map where every line in the body is evaluated and the first element is the key and the second the value
:makeMap @body? true

:applyMap v= .( ( ->map @@type :map ) infix ( ->transform @@type :function )
	l3.mapToMap { :map map :transform transform }
:applyMap @cat :map @doc ." Apply function to every element of a map.  If function is infix, it's handed key and value.  If it's prefix, it's handed the value.  Returns the new map.

:filterMap v= .( ( ->map @@type :map ) infix ( ->filter? @@type :function )
	l3.mapToMap { :map map :filter? filter? }
:filterMap @cat :map @doc ." Returns a map consisting of every member for which function returns true

:mapToArray v= .( ( ->map @@type :map ) infix ( ->transform @@type :function )
	l3.mapToArray { :map map :transform transform }
:mapToArray @cat :map @doc ." Apply function to every element of a map.  If function is infix, it's handed key and value.  If it's prefix, it's handed the value.  Returns a new array.

:filterMapToArray v= .( ( ->map @@type :map ) infix ( ->filter? @@type :function )
	l3.mapToArray { :map map :filter? filter? }
:filterMapToArray @cat :map @doc ." Returns an array consisting of every value in the map for which function returns true


//
// conditional

// ternary operator
:? v= .( ( ->do? @@type :bool ) infix [ ->doIfTrue ->doIfFalse ]
	l3.ifValue .{ :do? do? :ifTrue doIfTrue :ifFalse doIfFalse
:? @order 4
:? @cat :if @doc ." If condition is met, return first value, else return second value

:if v= func ( ->do? @@type :bool )
	l3.ifBody .{ :do? do? :body body
	l3.setValue { :key :l3.coFunction.if.done? :value do? :scope :parent }
	do?
:if @body? true
:if @order 5
:if @cat :if @doc ." If condition is met, do body

:elsif v= func ( ->do? @@type :bool )
	:doThis? v= .( ( !? l3.coFunction.if.done? ) &? do?
	l3.ifBody .{ :do? doThis? :body body
	l3.ifBody .{ :do? doThis? :body .[ .` l3.setValue .{ :key :l3.coFunction.if.done? :value true :scope :parent
	doThis?
:elsif @body? true
:elsif @order 5
:elsif @cat :if @doc ." If previous if and elsifs failed and this condition is met, do body

:else v= func()
	:doThis? v= .( !? l3.coFunction.if.done?
	l3.ifBody .{ :do? doThis? :body body
	doThis?
:else @body? true
:else @cat :if @doc ." If previous if and elsifs failed, do body


//
// loop

:while v= func ( ->cond @@type :rawLines )
	setScopeName :loop
	l3.loop .{ :check cond :body body
:while @body? true
:while @cat :loop @doc ." Repeat loop while condition is true

:for v= func .[ ->start ->cond ->change
	start
	setScopeName :loop
	l3.loop .{ :check cond :change change :body body
:for @body? true
:for @cat :loop @doc ." Call initialization code, then repeat loop while condition is true, evaluating final expression each time

:forEach v= .( ->key infix ->collection
	setScopeName :loop
	l3.forEach .{ :key key :collection collection :body body
:forEach @body? true
:forEach @cat :loop @doc ." Repeat loop for each item in collection.  Pattern is specified before forEach.  Collection is specified after forEach.

:forEachDelim v= .( ->key infix .[ ->collection ->delim
	setScopeName :loop
	l3.forEach .{ :key key :collection collection :body body :delim delim
:forEachDelim @body? true
:forEachDelim @cat :loop @doc ." Repeat loop for each item in collection.  Pattern is specified before forEach.  Collection is specified after forEach.  Can specify a delimiter that determines how each line is interpreted.

:break v= func()
	l3.popScope .{ :name :loop
:break @cat :loop @doc ." Pop the stack out of the current loop


//
// iterators

// function that allows for looping with an iterator
:=eachIn v= .( ->pattern infix ->input
	// one scope for the iterator and one for the body of the loop
	:iterScope v= l3.getScope .{ :scope :parent :createChild? true
	:loopScope v= l3.getScope .{ :scope :parent :createChild? true
	// store body because there will be a different body inside the loop
	:eachInBody v= body
	// a simple way to execute common code before the loop and inside it
	:doIterator v= .` l3.callWithScope { :function ( iterator ) :map iterScope :next input }
	:result v= ( l3.eval doIterator )
	while .` ( result ) !=? nil
		l3.setValue { :key pattern :value ( result ) :map loopScope :create? true }
		l3.evalWithScope { :value eachInBody :map loopScope }
		:result v= ( l3.eval doIterator )
	nil
:=eachIn @body? true
:=eachIn @cat :loop @doc ." Repeat loop for each item in a collection that supports an iterator.  Pattern is specified before =eachIn.  Collection is specified after =eachIn.

// specific iterator overloads

:iterator f= func ( ->array @@type :array )
	[ :i :count ] i= [ -1 ( array .size ) ]
	:i = i + 1
	( i <? count ) ? [ ` array . i ` nil ]
:iterator @iterator
:iterator @cat :iterator @doc ." Iterate over all items in a collection.

:iterator f= func .[ ( ->array1 @@type :array ) ( ->array2 @@type :array )
	[ :i :j ] i= [ 0 -1 ]
	[ :count1 :count2 ] i= [ ( array1 .size ) ( array2 .size ) ]
	:j = j + 1
	if j >=? count2
		[ :i :j ] = [ ( i + 1 ) 0 ]
	( i <? count1 ) ? [ ` [ ( array1 . i ) ( array2 . j ) ] ` nil ]

// todo: function overloading should give :scope precendence over :map
:iterator f= func ( ->scope @@type :scope )
	:current i= nil
	if current =? nil
		:current = scope
	else
		:current = :current .@ :l3.scope.parent
	current

:iterator f= func ( ->map @@type :map )
	[ :i :keys ] i= [ -1 ( l3.getMapKeys map ) ]
	:count i= keys .size
	:i = i + 1
	:result v= nil
	if i <? count
		:key v= keys . i
		:result = [ key ( map . key ) ]
	result

:iterator f= func ( ->f @@type :function )
	[ :i :count ] i= [ -1 ( ( f ) .size ) ]
	:i = i + 1
	( i <? count ) ? [ ( ( f ) . i ) nil ]

:iterator f= func ( ->lines @@type :rawLines )
	[ :i :count ] i= [ -1 ( lines .size ) ]
	:i = i + 1
	( i <? count ) ? [ ` lines . i ` nil ]


//
// strings

:=>str v= .( ->val postfix
	l3.toString ( val )
:=>str @order 2
:=>str @cat :string @doc ." Convert a value to a string

:+ f= .( ( ->str1 @@type :string ) infix ( ->str2 @@type :string )
	l3.stringConcat .{ :array .[ str1 str2
:+ @cat :string @doc ." Concatenate two strings

:"" v= " "
:"" @cat :string @doc ." TEMP: an empty string, needed until string delimiters handle white space correctly

:""" v= func()
	:list v= [ ]
	:str forEachDelim [ body :" ]
		list += str
	l3.stringConcat .{ :array list :spaces 1
:""" @body? true
:""" @cat :string @doc """
	Use the indented lines following this function as a single string.
	Useful for long strings such as @doc.

:\n v= l3.intToChar 13
:\n @cat :string @doc ." Represents a newline in a string

:\s v= l3.intToChar 32
:\s @cat :string @doc ." Represents a space in a string

:\t v= l3.intToChar 9
:\t @cat :string @doc ." Represents a tab in a string


//
// enumerated type

:=enum v= .( ( ->name @@type :string ) infix ( ->array @@type :array )
	:list v= { }
	:i v= 0
	:val forEach array
		:key v= name + " . " + val
		// metadata on the value describing enum name & key
		i @@ [ :l3.value.type name ]
		i @@ [ :l3.enum.key key ]
		:list = list + { key i }
		// store enum key/value on scope that called this function
		l3.setValue { :key key :value i :scope :grandparent }
		:i = i + 1
	// store entire map on scope that called this function
	:value v= l3.setValue { :key name :value list :scope :parent }
	// metadata on the enum
	value @@ [ :l3.value.type " enum " ]
	list
:=enum @cat :enum @doc ." Create an enumerated map of values


//
// math

:+ f= .( ( ->a @@type :number ) infix ( ->b @@type :number )
	l3.add [ a b ]
:+ @cat :math @doc ." Add two numbers

:- v= .(< l3.subtract [ #1 #2 ]
:- @cat :math @doc ." Subtract one number from another

:* f= .( ( ->a @@type :number ) infix ( ->b @@type :number )
	l3.multiply [ a b ]
:* @order 2
:* @cat :math @doc ." Multiply two numbers

:/ v= .(< l3.divide [ #1 #2 ]
:/ @order 2
:/ @cat :math @doc ." Divide the first number by the second number

:% v= .(< l3.modulo [ #1 #2 ]
:% @order 2
:% @cat :math @doc ." First number modulo the second number

:sqrt v= .(| l3.sqrt ##
:sqrt @cat :math @doc ." Compute the square root of a number

:<? v= .(< l3.lt [ #1 #2 ]
:<? @cat :math @doc ." True if a < b

:<=? v= .(< l3.lt [ #1 #2 ] |? #1 =? #2
:<=? @cat :math @doc ." True if a <= b

:>? v= .(< l3.gt [ #1 #2 ]
:>? @cat :math @doc ." True if a > b

:>=? v= .(< l3.gt [ #1 #2 ] |? #1 =? #2
:>=? @cat :math @doc ." True if a >= b

:min v= .(< ( #1 <? #2 ) ? [ #1 #2 ]
:min @cat :math @doc ." Returns the smallest of two values.

:max v= .(< ( #1 >? #2 ) ? [ #1 #2 ]
:max @cat :math @doc ." Returns the largest of two values.


//
// modules

:import v= .( func ( ->file @@type :string )
	l3.loadModule { :file file :scope " parent " }
:import @cat :module @doc ." Run the code from the given file.  Don't run if file has already been imported.

:reimport v= .( func ( ->file @@type :string )
	l3.loadModule { :file file :scope " parent " :force? true }
:reimport @cat :module @doc ." Run the code from the given file.  Reload even if module has been imported before.


//
// I/O

:print v= .(| l3.print .{ :value ##
:print @order 5
:print @cat :io @doc ." Print a value as a string
