l3.createEvalDelimiter :()
l3.createArrayDelimiter :[]
l3.setValue ( l3.createMap [ :key :{ :value ( l3.createDelimiter l3.createMap [ :start :{  :end :} :type :asArray :function l3.createMap ] ) ] )
l3.setValue { :key :// :value ( l3.createDelimiter { :start ://  :type :asComment } ) }

// the first lines created () as the value delimiter,
// [] as the array delimiter, {} as the map delimeter,
// and // as the remainder-of-line comment delimiter

// raw delimiter
l3.setValue { :key :` :value ( l3.createDelimiter { :start :`  :end :` :type :asRaw } ) }

// create a new variable and assign a value
l3.setValue { :key :<- :value ( l3.createFunction { :pre ->key :post ->value :order 5 :body [ ` l3.setValue { :key key :value value :scope :parent :create? true } ` ] } ) }

// create a new variable with a value of nil
l3.setValue { :key :var :value ( l3.createFunction { :post ->name :order 2 :body [ ` l3.setValue { :key name :value nil :scope :parent :create? true } ` ` name ` ] } ) }

// assignment
l3.setValue { :key := :value ( l3.createFunction { :pre ->key :post ->value :order 5 :body [ ` l3.setValue { :key key :value value :scope :parent :create? false } ` ] } ) }

// remainder of line is a value (like Haskell's $)
:/( <- ( l3.createDelimiter { :start :/(  :type :asValue } )

// remainder of line is an array
:/[ <- /( l3.createDelimiter { :start :/[  :type :asArray }

// remainder of line is a map
:/{ <- /( l3.createDelimiter { :start :/{  :type :asArray :function l3.createMap }

// remainder of line is raw
:/` <- /( l3.createDelimiter /{ :start :/`  :type :asRaw

// range comment delimiter
:/* <- /( l3.createDelimiter /{ :start :/*  :end :*/ :type :asComment

// string delimiter
:" <- /( l3.createDelimiter /{ :start :"  :end :" :type :asString
:' <- /( l3.createDelimiter /{ :start :'  :end :' :type :asString

// remainder of line is a string
:/" <- /( l3.createDelimiter /{ :start :/"  :type :asString
:/' <- /( l3.createDelimiter /{ :start :/'  :type :asString


//
// function definitions:

// a function which creates a prefix function
:func <- l3.createFunction { :post ->pattern }
	l3.createFunction { :post pattern }

// a function which creates an infix function
:infix <- /( l3.createFunction { :pre ->pattern1 :post ->pattern2 }
	l3.createFunction { :pre pattern1 :post pattern2 }

// a function which creates a postfix function
:postfix <- /( l3.createFunction { :pre ->pattern }
	l3.createFunction { :pre pattern }

// a function with no parameters which may decide to execute its body
:func() <- l3.createFunction { }
	l3.createFunction { }


//
// get & set

// member access using the . infix
:. <- /( ->a infix ->b
	l3.getValue /{ :object a :key b

// modify a value's metadata
:@ <- /( ->object infix [ ->key ->value ]
	l3.setValue /{ :map ( l3.getMetadata { :key object :writable? true } ) :key key :value value
	object

// get all the metadata attached to a value
:.@@ <- /( ->object postfix
	l3.getMetadata { :key object }

// get a particular piece of metadata attached to a value
:.@ <- /( ->object infix ->key
	l3.getValue /{ :object ( l3.getMetadata { :key object } ) :key key

// set the doc string on a value
:@doc <- /( ->object infix ->docString
	object @ /[ :l3.value.doc docString
:.@doc <- /( ->object postfix
	:metadata <- l3.getMetadata { :key object }
	:doc <- nil
	if metadata !=? nil
		:doc = l3.getValue /{ :object metadata :key :l3.value.doc
	doc
:.@doc	@doc	/" Get the documentation attached to a value

:@order <- /( ->object infix ->order
	object @ /[ :l3.value.order order
:@order @doc /" Add evaluation order to a value

:@body? <- /( ->object infix ->body?
	object @ /[ :body? body?
:@body? @doc /" Declare that a function requires a body

:@@ <- /( ->object infix [ ->key ->value ]
	l3.setValue /{ :map ( l3.getMetadata { :value object :writable? true } ) :key key :value value
	object
:@@ @doc /" Set metadata on a value, e.g. a parameter

:@@type <- /( ->object infix ->type
	object @@ /[ :l3.param.type type
:@@type @doc /" Restrict a parameter to a specific type

:@@default <- /( ->object infix ->default
	object @@ /[ :l3.param.default default
:@@default @doc /" Set the default value for a parameter if not present

:@@rest <- /( ->object postfix
	object @@ /[ :l3.param.rest true
:@@rest @doc /" Associated parameter will be filled with the remainder of the parameter values

:copy <- func ->value
	l3.copy /{ :value value
:copy	@doc	/" Make a copy of a value

:currentScope <- func()
	l3.getScope /{ :scope :parent
:currentScope @doc /" Get a map representing the current scope


// bump up precedence of .
:. @order 2


//
// add documentation to functions that have been previously definied

:(		@doc	/" Delimiter around code that is evaluated to a single value
:[		@doc	/" Delimiter around values in an array
:{		@doc	/" Delimiter around key/value pairs in a map
://		@doc	/" Remainder of line is ignored
:`		@doc	/" Delimiter around code that may be evaluated at a later time
:/(		@doc	/" Remainder of line is evaluated to a single value
:/[		@doc	/" Remainder of line is values in an array
:/{		@doc	/" Remainder of line is key/value pairs in a map
:/`		@doc	/" Remainder of line may be evaluated at a later time
:/*		@doc	/" Everything with delimiters is ignored
:"		@doc	/" Delimiter around a string
:'		@doc	/" Delimiter around a string
:/"		@doc	/" Remainder of line is a string
:/'		@doc	/" Remainder of line is a string
:<-		@doc	/" Create a new key/value pair in the current scope
:=		@doc	/" Assign a value to a key
:var	@doc	/" Create a new variable in the current scope
:func	@doc	/" Define a function that takes parameters after the function name
:infix	@doc	/" Define a function that takes parameters before and after the function name
:postfix @doc	/" Define a function that takes parameters before the function name
:func()	@doc	/" Define a function that takes no parameters
:.		@doc	/" Access the member of a map by key or array by index
:@		@doc	/" Modify a value's metadata
:.@		@doc	/" Get a value's metadata
:.@@	@doc	/" Get all of a value's metadata
:@doc	@doc	/" Add documentation to a value


//
// more function definitions


// definitions that take a pattern and one or more lines of code

:lambda <- func [ ->pattern ->line1 ( ->more @@rest ) ]
	l3.createFunction { :post pattern :body ( [ line1 ] +a more ) }
:lambda	@doc	/" Creates a function where the first param is the pattern and the rest are lines in the function body, e.g. lambda [ :x ` 2 + x ` ]

:(( <- /( l3.createDelimiter /{ :start :((  :end :)) :type :asArray :function lambda
:((		@doc	/" Creates a function where the first param is the pattern and the rest are lines in the function body, e.g. (( :x ` 2 + x ` ))

:/(( <- /( l3.createDelimiter /{ :start :/((  :type :asArray :function lambda
:/((	@doc	/" Remainder of line is a function where the first param is the pattern and the rest are lines in the function body, e.g. (( :x ` 2 + x ` ))


// definitions that create a prefix function, assume parameter is called ## and takes a single line of code

:lambda1 <- func ->line
	l3.createFunction { :post ->## :body [ line ] }
:lambda1	@doc	/" Creates a single line prefix function, assuming parameter is called ##, e.g. lambda1 ` 2 + ## `

:(| <- /( l3.createDelimiter /{ :start :(|  :end :|) :type :asRaw :function lambda1
:(|		@doc	/" Create a single line prefix function, assuming parameter is called ##, e.g. (| 2 + ## |)

:/(| <- /( l3.createDelimiter /{ :start :/(|  :type :asRaw :function lambda1
:/(|	@doc	/" Create a single line prefix function, assuming parameter is called ##, e.g. /(| 2 + ##


// definitions that create an infix function, assume parameters are called #1 and #2 and takes a single line of code

:lambda2 <- func ->line
	l3.createFunction { :pre ->#1 :post ->#2 :body [ line ] }
:lambda2	@doc	/" Create a single line infix function, assuming parameters are called #1 and #2, e.g. lambda2 ` #1 + #2 `

:(< <- /( l3.createDelimiter /{ :start :(<  :end :>) :type :asRaw :function lambda2
:(<		@doc	/" Create a single line infix function, assuming parameters are called #1 and #2, e.g. (< #1 + #2 >)

:/(< <- /( l3.createDelimiter /{ :start :/(<  :type :asRaw :function lambda2
:/(<	@doc	/" Create a single line infix function, assuming parameters are called #1 and #2, e.g. /(< #1 + #2


//
// logic

:&? <- /(< l3.and? [ #1 #2 ]
:&? @order 4
:&? @doc /" Return true if both values are true

:|? <- /(< l3.or? [ #1 #2 ]
:|? @order 4
:|? @doc /" Return true if either value is true

:!? <- /(| l3.not? ##
:!? @doc /" Returns true if value is false or false if value is true

:=? <- /(< l3.equal? [ #1 #2 ]
:=? @doc /" Return true if two values are equal

:!=? <- /(< !? l3.equal? [ #1 #2 ]
:!=? @doc /" Return true if two values are not equal

:=any? <- /( ->value infix ( ->array @@type :array )
	l3.anyEqual? [ value array ]
:=any? @doc /" Return true if value is equal to anything in array


//
// arrays

:.. <- /( ( ->start @@type :number ) infix ( ->end @@type :number )
	l3.createRange { :start start :end end }
:.. @doc /" Creates an array starting with one value and ending with another

:+a <- /( ->array1 infix ->array2
	l3.combine /[ array1 array2
:+a @doc /" Combine two arrays

:+= <- /( ( ->array @@type :array ) infix ->value
	l3.addToArray /{ :array array :value value
:+= @doc /" Add a value to an array

:countOf <- /( func ->value
	l3.getCount value
:countOf @doc /" Add a value to an array

:apply <- /( ( ->array @@type :array ) infix ( ->function @@type :function )
	l3.apply { :array array :function function }
:apply @doc /" Apply function to every element of array.  Function takes a single value.  Returns the new array.

:foldLeft <- /( ( ->array @@type :array ) infix ( ->function @@type :function )
	l3.foldLeft { :array array :function function }
:foldLeft @doc /" ((a[0] function a[1]) function a[2]) etc.  Returns a single value.

:fold <- /( foldLeft

:foldRight <- /( ( ->array @@type :array ) infix ( ->function @@type :function )
	l3.foldRight { :array array :function function }
:foldRight @doc /" (a[0] function (a[1] function a[2])) etc.  Returns a single value.

:filter <- /( ( ->array @@type :array ) infix ( ->function @@type :function )
	l3.filter { :array array :function function }
:filter @doc /" Returns an array consisting of every member for which function returns true

:makeArray <- func()
	:array <- nil
	:line forEach body
		:array = array +a [ line ]
	array
:makeArray @doc /" Make an array where every line in the body is evaluated and becomes an element in the array
:makeArray @body? true


//
// maps

:makeMap <- func()
	:map <- nil
	:submap forEachDelim [ body :{ ]
		:map = map +a submap
	map
:makeMap @doc /" Make a map where every line in the body is evaluated and the first element is the key and the second the value
:makeMap @body? true


//
// conditional

// ternary operator
:? <- /( ( ->do? @@type :bool ) infix [ ->doIfTrue ->doIfFalse ]
	l3.ifValue /{ :do? do? :ifTrue doIfTrue :ifFalse doIfFalse
:? @doc /" If condition is met, return first value, else return second value

:if <- func ( ->do? @@type :bool )
	l3.ifBody /{ :do? do? :body body
	l3.setValue { :key :l3.coFunction.if.done? :value do? :scope :parent }
	do?
:if @body? true
:if @order 5
:if @doc /" If condition is met, do body

:elsif <- func ( ->do? @@type :bool )
	:doThis? <- /( ( !? l3.coFunction.if.done? ) &? do?
	l3.ifBody /{ :do? doThis? :body body
	l3.ifBody /{ :do? doThis? :body /[ /` l3.setValue /{ :key :l3.coFunction.if.done? :value true :scope :parent
	doThis?
:elsif @body? true
:elsif @order 5
:elsif @doc /" If previous if and elsifs failed and this condition is met, do body

:else <- func()
	:doThis? <- /( !? l3.coFunction.if.done?
	l3.ifBody /{ :do? doThis? :body body
	doThis?
:else @body? true
:else @doc /" If previous if and elsifs failed, do body


//
// loop

:while <- func ( ->cond @@type :rawLines )
	l3.setScopeName /{ :name :loop
	l3.loop /{ :check cond :body body
:while @body? true
:while @doc /" Repeat loop while condition is true

:for <- func /[ ->start ->cond ->change
	start
	l3.setScopeName /{ :name :loop
	l3.loop /{ :check cond :change change :body body
:for @body? true
:for @doc /" Call initialization code, then repeat loop while condition is true, evaluating final expression each time

:forEach <- /( ->key infix ->collection
	l3.setScopeName /{ :name :loop
	l3.forEach /{ :key key :collection collection :body body
:forEach @body? true
:forEach @doc /" Repeat loop for each item in collection.  Pattern is specified before forEach.  Collection is specified after forEach.

:forEachDelim <- /( ->key infix /[ ->collection ->delim
	l3.setScopeName /{ :name :loop
	l3.forEach /{ :key key :collection collection :body body :delim delim
:forEachDelim @body? true
:forEachDelim @doc /" Repeat loop for each item in collection.  Pattern is specified before forEach.  Collection is specified after forEach.  Can specify a delimiter that determines how each line is interpreted.

:break <- func()
	l3.popScope /{ :name :loop
:break @doc /" Pop the stack out of the current loop


//
// strings

:=>str <- /( ->val postfix
	l3.toString ( val )
:=>str @order 2
:=>str @doc /" Convert a value to a string

// todo: switch to + when overloading is supported
:+s <- /( ( ->str1 @@type :string ) infix ( ->str2 @@type :string )
	l3.stringConcat /{ :array /[ str1 str2
:+s @doc /" Concatenate two strings

:"" <- " "
:"" @doc /" TEMP: an empty string, needed until string delimiters handle white space correctly

:""" <- func()
	:list <- [ ]
	:str forEachDelim [ body :" ]
		list += str
	l3.stringConcat /{ :array list :spaces 1
:""" @body? true
:""" @doc """
	Use the indented lines following this function as a single string.
	Useful for long strings such as @doc.


//
// enumerated type

:enum <- /( ( ->name @@type :string ) infix ( ->array @@type :array )
	:list <- { }
	:i <- 0
	:val forEach array
		:key <- name +s " . " +s val
		// metadata on the value describing enum name & key
		i @@ [ :l3.value.type name ]
		i @@ [ :l3.enum.key key ]
		:list = list +a { key i }
		// store enum key/value on scope that called this function
		l3.setValue { :key key :value i :scope :grandparent }
		:i = i + 1
	// store entire map on scope that called this function
	:value <- l3.setValue { :key name :value list :scope :parent }
	// metadata on the enum
	value @@ [ :l3.value.type " enum " ]
	list
:enum @doc /" Create an enumerated map of values


//
// math

:+ <- /(< l3.add [ #1 #2 ]
:+ @doc /" Add two numbers

:- <- /(< l3.subtract [ #1 #2 ]
:- @doc /" Subtract one number from another

:* <- /(< l3.multiply [ #1 #2 ]
:* @order 2
:* @doc /" Multiply two numbers

:/ <- /(< l3.divide [ #1 #2 ]
:/ @order 2
:/ @doc /" Divide the first number by the second number

:% <- /(< l3.modulo [ #1 #2 ]
:% @order 2
:% @doc /" First number modulo the second number

:sqrt <- /(| l3.sqrt ##
:sqrt @doc /" Compute the square root of a number

:<? <- /(< l3.lt [ #1 #2 ]
:<? @doc /" True if a < b

:>? <- /(< l3.gt [ #1 #2 ]
:>? @doc /" True if a > b

:min <- /(< ( #1 <? #2 ) ? [ #1 #2 ]
:min @doc /" Returns the smallest of two values.

:max <- /(< ( #1 >? #2 ) ? [ #1 #2 ]
:max @doc /" Returns the largest of two values.


//
// modules

:import <- /( func ( ->file @@type :string )
	l3.loadModule { :file file :scope " parent " }
:import @doc /" Run the code from the given file


//
// I/O

:print <- /(| l3.print /{ :value ##
:print @order 5
:print @doc /" Print a value as a string
