//
// Unittest framework
//
// Provides tools for attaching unittests to functions (@unittest),
//	validating that all functions pass their tests and
//	have attached documentation (@doc)
//
// :myFunc @unittest bodyFunc
//		doSomething
//

:unittest v= func [ ->targetFile ->testFile ]
	// import files into local scope
	import targetFile
	import testFile
	// stub out doc & unittest so local vars don't affect results
	:targetFile @doc ."
	:testFile @doc ."
	:targetFile @unittest true
	:testFile @unittest true
	// run tests on local scope
	unittestScope currentScope
:unittest @cat :unittest @doc ." For a given implementation file, run all the tests defined in a test file.

:runTestFile v= func ->testFile
	import testFile
	:scope v= currentScope
	testFunction .[ runTests :runTests scope
:runTestFile @cat :unittest @doc ." Run all the tests defined in a test file.


:unittestScope v= func ->scope
	var :success? = true
	:success? = success? &? testFunction .[ checkDocs :checkDocs scope
	:success? = success? &? testFunction .[ runUnittests :runUnittests scope
	success?
:unittestScope @cat :unittest @doc ." Run tests and check for docstrings on everything in scope

:testFunction v= func .[ ->function ->name ->scope
	[ :success? :failures ] v= function scope
	if success?
		print " ---- " + name + ." : succeeded
	else
		print " ---- " + name + ." : failed
		print failures
	success?
:testFunction @cat :unittest @doc """
	Run a function and output failures if any.
	Takes a function that returns [ success? arrayOfFailures ] , the name of the test, and a scope to operate on.


:checkDocs v= func ->scope
	var :failures = scope filterMap (< #1 .@doc =? nil >) mapToArray (< #1 >)
	[ ( ( failures .size ) =? 0 ) failures ]
:checkDocs @cat :unittest @doc """
	Check if everything in scope has doc metadata.
	Returns [ success? arrayOfFailures ]


:@unittest v= .( ->object infix ->function
	object @ .[ :l3.value.unittest function
:@unittest	@cat :unittest @doc ." Attach a unittest to a value

:.@unittest v= .( ->object postfix
	:metadata v= l3.getMetadata { :key object }
	:test v= nil
	if metadata !=? nil
		:test = l3.getValue .{ :object metadata :key :l3.value.unittest
	test
:.@unittest	@cat :unittest @doc ." Get the unittest attached to a value

:stubFunc v= func()
	true
:stubFunc @cat :unittest @doc ." Used for stubbing out unneeded unittests


:assert=? v= .( ->expected infix ->actual
	if expected !=? actual
		print " FAILED : " + testName
		print " .expected: " + expected =>str
		print " ...actual: " + actual =>str
		l3.popScope { :name :testScope :return false }
:assert=? @order 6
:assert=? @cat :unittest @doc """
	A test can assert objects are equal.
	If they're not, the current test function aborts & fails.

:assertTrue? v= func ->cond
	if !? l3.eval cond
		print ." ...failed...
		print " FAILED : " + testName
		print " ...expected: true "
		print " .expression: " + cond =>str
		l3.popScope { :name :testScope :return false }
:assertTrue? @order 6
:assertTrue? @cat :unittest @doc """
	A test can assert something is true.
	If it's not, the current test function aborts & fails.

:assertFalse? v= func ->cond
	if l3.eval cond
		print ." ...failed...
		print " FAILED : " + testName
		print " ...expected: false "
		print " .expression: " + cond =>str
		l3.popScope { :name :testScope :return false }
:assertFalse? @order 6
:assertFalse? @cat :unittest @doc """
	A test can assert something is false.
	If it's not, the current test function aborts & fails.

:assertFail v= func ->message
	print ." ...failed...
	print " FAILED : " + testName
	print " message: " + message
	l3.popScope { :name :testScope :return false }
:assertFail @cat :unittest @doc """
	A test can say it fails immediately if this line of code is run.


:runUnittests v= func ->scope
	var :failures = [ ]
	[ :testName _ ] forEach scope
		var :success? = if true
			// asserts will exit this scope & the above 'if' will return false
			setScopeName :testScope
			// run the test
			if testName .@unittest =? nil		// fail if no test
				failures += testName
		// fail if function asserted
		if !? success?
			failures += testName
	[ ( ( failures .size ) =? 0 ) failures ]
:runUnittests @cat :unittest @doc """
	Run .@unittest on every value in the scope.
	A unittest fails if it isn't present or if an assert fails inside it.

:runTests v= func ->scope
	var :failures = [ ]
	:mapOfTests v= scope filterMap (< l3.getType { :key #1 } =? :function >)
	[ :testName :testFunction ] =eachIn mapOfTests
		var :success? = if true
			// asserts will exit this scope & the above 'if' will return false
			setScopeName :testScope
			// run the test
			testFunction
		// fail if function asserted
		if !? success?
			failures += testName
	[ ( ( failures .size ) =? 0 ) failures ]
:runTests @cat :unittest @doc """
	Run every function in the scope as a test.
	A test fails if an assert fails inside it.
