//
// Unittest framework
//
// Provides tools for attaching unittests to functions (@unittest),
//	validating that all functions pass their tests and
//	have attached documentation (@doc)
//
// :myFunc @unittest bodyFunc
//		doSomething
//

:unittest v= func1 [ ->targetFile ->testFile ]
	// import files into local scope
	import targetFile
	import testFile
	// stub out doc & unittest so local vars don't affect results
	:targetFile @unittest true @doc ."
	:testFile @unittest true @doc ."
	// run tests on local scope
	unittestScope currentScope
:unittest @cat :unittest @doc ." For a given implementation file, run all the tests defined in a test file.

:runTestFile v= func1 ->testFile
	import testFile
	:scope v= currentScope
	testFunction .[ runTests :runTests scope
:runTestFile @cat :unittest @doc ." Run all the tests defined in a test file.


:unittestScope v= func1 ->scope
	var :success? = true
	:success? = success? &? testFunction .[ checkDocs :checkDocs scope
	:success? = success? &? testFunction .[ runUnittests :runUnittests scope
	success?
:unittestScope @cat :unittest @doc ." Run tests and check for docstrings on everything in scope

:testFunction v= func1 .[ ->function ->name ->scope
	[ :success? :failures ] v= function scope
	if success?
		print " ---- " + name + ." : succeeded
	else
		print " ---- " + name + ." : failed
		print failures
	success?
:testFunction @cat :unittest @doc """
	Run a function and output failures if any.
	Takes a function that returns [ success? arrayOfFailures ] , the name of the test, and a scope to operate on.


:checkDocs v= func1 ->scope
	var :failures = scope filterMap (< #1 .@doc =? nil >) mapToArray (< #1 >)
	[ ( ( failures .size ) =? 0 ) failures ]
:checkDocs @cat :unittest @doc """
	Check if everything in scope has doc metadata.
	Returns [ success? arrayOfFailures ]


:@unittest v= .( ->object 1func1 ->function
	object @ .[ :l3.value.unittest function
:@unittest	@cat :unittest @doc ." Attach a unittest to a value

:.@unittest v= .( ->object 1func
	:metadata v= l3.getMetadata { :key object }
	:test v= nil
	if metadata !=? nil
		:test = l3.getValue .{ :object metadata :key :l3.value.unittest
	test
:.@unittest	@cat :unittest @doc ." Get the unittest attached to a value

:noTestNeeded v= func0
	true
:noTestNeeded @cat :unittest @doc ." Used for stubbing out unneeded unittests

:testNYI v= func0
	true
:testNYI @cat :unittest @doc ." Used to indicate that a unittest is not yet implemented


:assert=? v= .( ->expected 1func1 ->actual
	if expected !=? actual
		l3.throw { :type :assert :expected ( expected ) :actual ( actual ) }
:assert=? @order 6
:assert=? @cat :unittest @doc """
	A test can assert objects are equal.
	If they're not, the current test function aborts & fails.

:assertTrue? v= func1 ->cond
	if !? l3.eval cond
		l3.throw { :type :assert :expected true :expression ( cond ) }
:assertTrue? @order 6
:assertTrue? @cat :unittest @doc """
	A test can assert something is true.
	If it's not, the current test function aborts & fails.

:assertFalse? v= func1 ->cond
	if l3.eval cond
		l3.throw { :type :assert :expected false :expression ( cond ) }
:assertFalse? @order 6
:assertFalse? @cat :unittest @doc """
	A test can assert something is false.
	If it's not, the current test function aborts & fails.

:assertFail v= func1 ->message
	l3.throw { :type :assert :message message }
:assertFail @cat :unittest @doc """
	A test can say it fails immediately if this line of code is run.

:dumpAssert v= func1 [ ->testName ->e ]
	print " FAILED : " + testName
	if ( e . :expected ) !=? nil
		print ."[ :.expected: \s ( e . :expected )
	if ( e . :actual ) !=? nil
		print ."[ :...actual: \s ( e . :actual )
	if ( e . :expression ) !=? nil
		print ."[ :.expression: \s ( e . :expression )
	if ( e . :message ) !=? nil
		print ."[ :....message: \s ( e . :message )
:dumpAssert @doc ." Print details about an assert

:runUnittests v= func1 ->scope
	var :failures = [ ]
	[ :testName _ ] forEach scope
		try
			if testName .@unittest =? nil		// fail if no test
				failures += testName
				print ."[ " missing unittest: " \s testName
		catch :e
			failures += testName
			dumpAssert [ testName e ]
		endTry
	[ ( ( failures .size ) =? 0 ) failures ]
:runUnittests @cat :unittest @doc """
	Run .@unittest on every value in the scope.
	A unittest fails if it isn't present or if an assert fails inside it.

:runTests v= func1 ->scope
	var :failures = [ ]
	:mapOfTests v= scope filterMap (< l3.getType { :key #1 } =? :function >)
	[ :testName :testFunction ] =eachIn mapOfTests
		try
			// run the test
			testFunction
		catch :e
			failures += testName
			dumpAssert [ testName e ]
		endTry
	[ ( ( failures .size ) =? 0 ) failures ]
:runTests @cat :unittest @doc """
	Run every function in the scope as a test.
	A test fails if an assert fails inside it.
