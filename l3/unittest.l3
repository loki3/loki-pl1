//
// Unittest framework
//
// Provides tools for attaching unittests to functions (@unittest),
//	validating that all functions pass their tests and
//	have attached documentation (@doc)
//
// :myFunc @unittest bodyFunc
//		doSomething
//

:unittest <- func [ ->targetFile ->testFile ]
	// import files into local scope
	import targetFile
	import testFile
	// stub out doc & unittest so local vars don't affect results
	:targetFile @doc /"
	:testFile @doc /"
	:targetFile @unittest true
	:testFile @unittest true
	// run tests on local scope
	unittestScope currentScope
:unittest @doc /" For a given implementation file, run all the tests defined in a test file.

:unittestScope <- func ->scope
	var :success? = true
	:success? = success? &? testFunction /[ checkDocs :checkDocs scope
	:success? = success? &? testFunction /[ runUnittests :runUnittests scope
	success?
:unittestScope @doc /" Run tests and check for docstrings on everything in scope

:testFunction <- func /[ ->function ->name ->scope
	[ :success? :failures ] <- function scope
	if success?
		print " ---- " +s name +s /" : succeeded
	else
		print " ---- " +s name +s /" : failed
		print failures
	success?
:testFunction @doc /" Run a function and output failures if any.  Takes a function that returns [ success? arrayOfFailures ], the name of the test, and a scope to operate on.


:checkDocs <- func ->scope
	var :failures = [ ]
	:f forEach scope
		if ( f . 0 ) .@doc =? nil
			failures += f . 0
	[ ( ( countOf failures ) =? 0 ) failures ]
:checkDocs @doc /" Check if everything in scope has doc metadata.  Returns [ success? arrayOfFailures ]


:@unittest <- /( ->object infix ->function
	object @ /[ :l3.value.unittest function
:@unittest	@doc /" Attach a unittest to a value

:.@unittest <- /( ->object postfix
	:metadata <- l3.getMetadata { :key object }
	:test <- nil
	if metadata !=? nil
		:test = l3.getValue /{ :object metadata :key :l3.value.unittest
	test
:.@unittest	@doc /" Get the unittest attached to a value

:stubFunc <- func()
	true
:stubFunc @doc /" Used for stubbing out unneeded unittests


:assert=? <- /( ->expected infix ->actual
	if expected !=? actual
		print " FAILED : " +s unittestName
		print " .expected: " +s expected =>str
		print " ...actual: " +s actual =>str
		l3.popScope { :name :runUnittests :return false }
:assert=? @order 5
:assert=? @doc /" Unittests can assert objects are equal.  If they're not, the unittest aborts & fails.

:assertTrue? <- func ->cond
	if !? l3.eval cond
		print /" ...failed...
		print " FAILED : " +s unittestName
		print " ...expected: true "
		print " .expression: " +s cond =>str
		l3.popScope { :name :runUnittests :return false }
:assertTrue? @order 5
:assertTrue? @doc /" Unittests can assert something is true.  If it's not, the unittest aborts & fails.

:assertFalse? <- func ->cond
	if l3.eval cond
		print /" ...failed...
		print " FAILED : " +s unittestName
		print " ...expected: false "
		print " .expression: " +s cond =>str
		l3.popScope { :name :runUnittests :return false }
:assertFalse? @order 5
:assertFalse? @doc /" Unittests can assert something is false.  If it's not, the unittest aborts & fails.

:assertFail <- func ->message
	print /" ...failed...
	print " FAILED : " +s unittestName
	print " message: " +s message
	l3.popScope { :name :runUnittests :return false }
:assertFail @doc /" Unittests can say they fail immediately if this line of code is run.


:runUnittests <- func ->scope
	var :failures = [ ]
	:f forEach scope
		var :unittestName = f . 0
		var :success? = if true
			// asserts will exit this scope & the above 'if' will return false
			l3.setScopeName { :name :runUnittests }
			// run the test
			if unittestName .@unittest =? nil		// fail if no test
				failures += unittestName
		// fail if function asserted
		if !? success?
			failures += unittestName
	[ ( ( countOf failures ) =? 0 ) failures ]
:runUnittests @doc /" Run .@unittest on every value in the scope.  A unittest fails if it isn't present or if an assert fails.
