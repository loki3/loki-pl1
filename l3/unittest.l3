//
// Unittest framework
//
// Provides tools for attaching unittests to functions (@unittest),
//	validating that all functions pass their tests and
//	have attached documentation (@doc)
//
// :myFunc @unittest bodyFunc
//		doSomething
//

:unittest v= func [ ->targetFile ->testFile ]
	// import files into local scope
	import targetFile
	import testFile
	// stub out doc & unittest so local vars don't affect results
	:targetFile @doc ."
	:testFile @doc ."
	:targetFile @unittest true
	:testFile @unittest true
	// run tests on local scope
	unittestScope currentScope
:unittest @cat :unittest @doc ." For a given implementation file, run all the tests defined in a test file.

:unittestScope v= func ->scope
	var :success? = true
	:success? = success? &? testFunction .[ checkDocs :checkDocs scope
	:success? = success? &? testFunction .[ runUnittests :runUnittests scope
	success?
:unittestScope @cat :unittest @doc ." Run tests and check for docstrings on everything in scope

:testFunction v= func .[ ->function ->name ->scope
	[ :success? :failures ] v= function scope
	if success?
		print " ---- " +s name +s ." : succeeded
	else
		print " ---- " +s name +s ." : failed
		print failures
	success?
:testFunction @cat :unittest @doc """
	Run a function and output failures if any.
	Takes a function that returns [ success? arrayOfFailures ] , the name of the test, and a scope to operate on.


:checkDocs v= func ->scope
	var :failures = scope filterMap (< #1 .@doc =? nil >) mapToArray (< #1 >)
	[ ( ( countOf failures ) =? 0 ) failures ]
:checkDocs @cat :unittest @doc """
	Check if everything in scope has doc metadata.
	Returns [ success? arrayOfFailures ]


:@unittest v= .( ->object infix ->function
	object @ .[ :l3.value.unittest function
:@unittest	@cat :unittest @doc ." Attach a unittest to a value

:.@unittest v= .( ->object postfix
	:metadata v= l3.getMetadata { :key object }
	:test v= nil
	if metadata !=? nil
		:test = l3.getValue .{ :object metadata :key :l3.value.unittest
	test
:.@unittest	@cat :unittest @doc ." Get the unittest attached to a value

:stubFunc v= func()
	true
:stubFunc @cat :unittest @doc ." Used for stubbing out unneeded unittests


:assert=? v= .( ->expected infix ->actual
	if expected !=? actual
		print " FAILED : " +s unittestName
		print " .expected: " +s expected =>str
		print " ...actual: " +s actual =>str
		l3.popScope { :name :runUnittests :return false }
:assert=? @order 6
:assert=? @cat :unittest @doc """
	Unittests can assert objects are equal.
	If they're not, the current unittest function aborts & fails.

:assertTrue? v= func ->cond
	if !? l3.eval cond
		print ." ...failed...
		print " FAILED : " +s unittestName
		print " ...expected: true "
		print " .expression: " +s cond =>str
		l3.popScope { :name :runUnittests :return false }
:assertTrue? @order 6
:assertTrue? @cat :unittest @doc """
	Unittests can assert something is true.
	If it's not, the current unittest function aborts & fails.

:assertFalse? v= func ->cond
	if l3.eval cond
		print ." ...failed...
		print " FAILED : " +s unittestName
		print " ...expected: false "
		print " .expression: " +s cond =>str
		l3.popScope { :name :runUnittests :return false }
:assertFalse? @order 6
:assertFalse? @cat :unittest @doc """
	Unittests can assert something is false.
	If it's not, the current unittest function aborts & fails.

:assertFail v= func ->message
	print ." ...failed...
	print " FAILED : " +s unittestName
	print " message: " +s message
	l3.popScope { :name :runUnittests :return false }
:assertFail @cat :unittest @doc ." Unittests can say they fail immediately if this line of code is run.


:runUnittests v= func ->scope
	var :failures = [ ]
	:f forEach scope
		var :unittestName = f . 0
		var :success? = if true
			// asserts will exit this scope & the above 'if' will return false
			setScopeName :runUnittests
			// run the test
			if unittestName .@unittest =? nil		// fail if no test
				failures += unittestName
		// fail if function asserted
		if !? success?
			failures += unittestName
	[ ( ( countOf failures ) =? 0 ) failures ]
:runUnittests @cat :unittest @doc """
	Run .@unittest on every value in the scope.
	A unittest fails if it isn't present or if an assert fails inside it.
