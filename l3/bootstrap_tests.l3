// unittests for bootstrap.l3

:(		@unittest func()
	14 assert=? ( 4 + 3 ) * 2
	10 assert=? 4 + ( 3 * 2 )

:[		@unittest func()
	:array assert=? l3.getType { :value [ 1 2 ] }
	4 assert=? l3.getCount [ 3 4 5 6 ]

:{		@unittest func()
	:map assert=? l3.getType { :value { :a 1 :b 2 } }
	2 assert=? l3.getCount { :a 1 :b 2 }

://		@unittest func()
	// assertTrue? false
	true

:`		@unittest func()
	8 assert=? l3.eval ` 5 + 3 `

:.(		@unittest func()
	10 assert=? 4 + .( 3 * 2

:.[		@unittest func()
	3 assert=? l3.getCount .[ 2 3 4

:.{		@unittest func()
	:map assert=? l3.getType .{ :value .{ :a 1 :b 2 

:.`		@unittest func()
	8 assert=? l3.eval .` 5 + 3

:/*		@unittest func()
	:a /* comment */ v= /* comment */ 5 + 3
	8 assert=? a

:"		@unittest func()
	:asdf assert=? " asdf "

:'		@unittest func()
	:asdf assert=? ' asdf '

:."		@unittest func()
	:asdf assert=? ." asdf

:.'		@unittest func()
	:asdf assert=? .' asdf

:v=		@unittest func()
	:a v= 5
	5 assert=? a

:f=		@unittest func()
	// try overloads on different numbers of parameters
	:f f= .(( :a ` a + 1 `
	5 assert=? f 4
	:f f= .(( [ :a :b :c ] ` a + b + c `
	5 assert=? f 4
	9 assert=? f .[ 4 2 3
	:f f= .(( [ :a :b ] ` a * b `
	5 assert=? f 4
	8 assert=? f .[ 4 2
	9 assert=? f .[ 4 2 3
	
	// try overloads based on type
	// general
	:g f= .(( :a ` a + 1 `
	5 assert=? g 4
	// most specific
	:g f= .(( ( :a @@type :float ) ` a + 3 `
	5 assert=? g 4
	7 assert=? g 4.0
	// intermediate
	:g f= .(( ( :a @@type :number ) ` a + 2 `
	6 assert=? g 4
	7 assert=? g 4.0

:=		@unittest func()
	:a v= 5
	:a = 4
	4 assert=? a

:var	@unittest func()
	var :a = 5
	5 assert=? a


//
// function definitions:

:func	@unittest func()
	:a v= func ->b
		b + 2
	7 assert=? func 5

:infix	@unittest func()
	:a v= .( ->b infix ->c
		b + c
	42 assert=? 40 a 2

:postfix @unittest func()
	:a v= .( ->b postfix
		b + 2
	5 assert=? 3 a

:func()	@unittest func()
	:a v= func()
		3.5
	3.5 assert=? a


//
// get & set

:.		@unittest func()
	4 assert=? { :a 3 :b 4 :c 5 } . :b
	3 assert=? [ 6 5 4 3 2 ] . 3
	// map default
	:a v= { :a 9 :b 12 } @@default 42
	12 assert=? a . :b
	42 assert=? a . :notThere
	// array default
	:b v= [ 200 400 ] @@default 314
	200 assert=? b . 0
	400 assert=? b . 1
	314 assert=? b . 2
	314 assert=? b . -1

:@		@unittest func()
	:a v= 1
	:a @ [ :blah :something ]
	:something assert=? ( l3.getMetadata { :key :a } ) . :blah

:.@		@unittest func()
	:a v= 1
	:a @ [ :blah :something ]
	:something assert=? :a .@ :blah

:.@@	@unittest func()
	:a v= 1
	:a @ [ :blah :something ]
	{ :blah :something } assert=? :a .@@

:@doc	@unittest func()
	:a v= 1
	:a @doc :whatever
	:whatever assert=? :a .@doc

:.@doc	@unittest func()
	:a v= 1.5
	:a @doc :whatever
	:whatever assert=? :a .@doc

:@cat	@unittest func()
	:a v= 1
	:a @cat :something
	:something assert=? :a .@cat

:.@cat	@unittest func()
	:a v= 1.5
	:a @cat :something
	:something assert=? :a .@cat

:@order @unittest func()
	:a v= (| ## + 2 |)
	// a should be applied after *
	:a @order 5
	12 assert=? a 5 * 2
	// a should be applied before *
	:a @order 1
	14 assert=? a 5 * 2

:@body? @unittest func()
	:a v= func()
		:result v= nil
		:line forEach body
			:result = result + [ line ]
	:a @body? true
	:b v= a
		3
		4
	[ 3 4 ] assert=? b

:@type @unittest func()
	:a v= 1
	:a @type :int
	:int assert=? :a .@ :l3.value.type

:@iterator @unittest func()
	:a v= (| ## + 1 |)
	:a @iterator
	:iterator assert=? :a .@ :l3.value.type

:@@ @unittest func()
	:a v= 1
	a @@ [ :key 2 ]
	2 assert=? :a .@ :key

:@@type @unittest func()
	:a v= 1
	a @@type :int
	:int assert=? :a .@ :l3.param.type

:@@default @unittest func()
	:a v= 1
	a @@default 2
	2 assert=? :a .@ :l3.param.default

:@@rest @unittest func()
	:a v= 1
	a @@rest
	true assert=? :a .@ :l3.param.rest

:copy	@unittest func()
	:a v= 1
	1 assert=? copy a
	:str assert=? copy :str

:currentScope @unittest func()
	// create accumulator outside the nested scope
	:map v= { }
	if true
		// add some vars in this scope to examine
		:a v= 1
		:b v= 2
		var :i forEach currentScope
			// ignore vars that the forEach created
			if ( ( i . 0 ) =? :a |? ( i . 0 ) =? :b )
				:map = map + { ( i . 0 ) ( i . 1 ) }
	{ :a 1 :b 2 } assert=? map

:setScopeName @unittest stubFunc

:i= @unittest func()
	[ :a :b ] i= [ 4 5 ]
	4 assert=? a
	5 assert=? b
	[ :c :b ] i= [ 9 22 ]
	5 assert=? b
	9 assert=? c
	// make sure nested scope doesn't use outter scope
	:val v= 1
	if true
		1 assert=? val
		:val i= 2
		2 assert=? val
	1 assert=? val


//
// more function definitions

:lambda	@unittest func()
	:2+ v= .( lambda .[ :x .` 2 + x
	3 assert=? 2+ 1

:((		@unittest func()
	:2+ v= (( :x ` 2 + x ` ))
	3 assert=? 2+ 1
	:mult v= (( [ :a :b ] ` a * b ` ))
	12 assert=? mult [ 6 2 ]

:.((	@unittest func()
	:2+ v= .(( :x ` 2 + x `
	3 assert=? 2+ 1

:lambda1	@unittest func()
	:2+ v= .( lambda1 .` ## + 2
	3 assert=? 2+ 1

:(|		@unittest func()
	:2+ v= (| ## + 2 |)
	3 assert=? 2+ 1

:.(|	@unittest func()
	:2+ v= .(| ## + 2
	3 assert=? 2+ 1

:lambda2	@unittest func()
	:div v= .( lambda2 ` #1 / #2 `
	3 assert=? 6 div 2

:(<		@unittest func()
	:div v= (< #1 / #2 >)
	3 assert=? 6 div 2

:.(<	@unittest func()
	:div v= .(< #1 / #2
	3 assert=? 6 div 2


//
// types

:_ @unittest func()
	nil assert=? _
	// _ in pattern matching means ignore the value
	[ :a _ :b ] v= [ 3 5 7 ]
	3 assert=? a
	7 assert=? b


//
// logic

:&? @unittest func()
	assertTrue?  true  &? true
	assertFalse? true  &? false
	assertFalse? false &? true
	assertFalse? false &? false

:|? @unittest func()
	assertTrue?  true  |? true
	assertTrue?  true  |? false
	assertTrue?  false |? true
	assertFalse? false |? false

:!? @unittest func()
	assertTrue?  !? false
	assertFalse? !? true

:=? @unittest func()
	assertTrue?  5 =? 5
	assertFalse? 5 =? 4

:!=? @unittest func()
	assertTrue?  5 !=? 4
	assertFalse? 5 !=? 5

:=any? @unittest func()
	assertTrue?  5 =any? [ 3 5 6 9 ]
	assertFalse? 4 =any? [ 3 5 6 9 ]


//
// arrays

:.. @unittest func()
	[ 3 4 5 6 ] assert=? ( 3 .. 6 )

:+ @unittest func()
	[ 3 4 5 6 ] assert=? [ 3 4 ] + [ 5 6 ]
	[ 3 4 5 6 ] assert=? [ 3 4 5 ] + 6
	[ 3 4 5 6 ] assert=? [ 3 4 5 6 ] + [ ]
	[ 3 4 5 6 ] assert=? [ 3 4 5 6 ] + nil

:+= @unittest func()
	// array addition
	:a v= [ 3 4 5 ]
	// todo: perhaps it should be :a += 6
	a += 6
	[ 3 4 5 6 ] assert=? a

:.size @unittest func()
	3 assert=? [ 5 6 8 ] .size
	2 assert=? { :a 1 :b 3 } .size
	5 assert=? " qwert " .size

:apply @unittest func()
	[ 6 10 14 ] assert=? [ 3 5 7 ] apply (| ## * 2 |)

:foldLeft @unittest func()
	1 assert=? [ 27 9 3 ] foldLeft (< #1 / #2 >)

:foldRight @unittest func()
	9 assert=? [ 27 9 3 ] foldRight (< #1 / #2 >)

:filter @unittest func()
	[ 3 5 7 ] assert=? [ 2 3 4 5 6 7 8 ] filter (| ## % 2 =? 1 |)

:makeArray @unittest func()
	:a v= makeArray
		:asdf
		3.5
		2
	[ :asdf 3.5 2 ] assert=? a


//
// maps

:makeMap @unittest func()
	:a v= makeMap
		:1 2
		:3 4
	{ :1 2 :3 4 } assert=? a

:applyMap @unittest func()
	{ :a 42 :b 17 } assert=? { :a 84 :b 34 } applyMap (| ## / 2 |)

:filterMap @unittest func()
	{ :b 2 :d 6 } assert=? { :a 1 :b 2 :c 3 :d 6 } filterMap (| ## % 2 =? 0 |)
	{ :c 3 }      assert=? { :a 1 :b 2 :c 3 :d 6 } filterMap (< #1 =? :c >)

:mapToArray @unittest func()
	[ 42 17 ] assert=? { :a 84 :b 34 } mapToArray (| ## / 2 |)

:filterMapToArray @unittest func()
	[ 2 6 ] assert=? { :a 1 :b 2 :c 3 :d 6 } filterMapToArray (| ## % 2 =? 0 |)
	[ 3 ]   assert=? { :a 1 :b 2 :c 3 :d 6 } filterMapToArray (< #1 =? :c >)


//
// conditional

:? @unittest func()
	2 assert=? true  ? [ 2 3 ]
	3 assert=? false ? [ 2 3 ]

:if @unittest func()
	// if is run
	:a v= false
	if true
		:a = true
	assertTrue? a
	// if is skipped
	if false
		assertFail ." if shouldn't have been called

:elsif @unittest func()
	// if is run, not elsif
	:a v= 0
	if true
		:a = 1
	elsif true
		assertFail ." elsif shouldn't have been called
	1 assert=? a
	// elsif is run
	:a v= 0
	if false
		assertFail ." if shouldn't have been called
	elsif true
		:a = 2
	2 assert=? a
	// if & elsif are skipped
	:a v= 0
	if false
		assertFail ." if shouldn't have been called
	elsif false
		assertFail ." elsif shouldn't have been called
	0 assert=? a

:else @unittest func()
	// if is run, not else
	:a v= 0
	if true
		:a = 1
	else
		assertFail ." else shouldn't have been called
	1 assert=? a
	// else is run
	:a v= 0
	if false
		assertFail ." if shouldn't have been called
	else
		:a = 2
	2 assert=? a
	
	// if is run
	:a v= 0
	if true
		:a = 1
	elsif true
		assertFail ." elsif shouldn't have been called
	else
		assertFail ." else shouldn't have been called
	1 assert=? a
	// elsif is run
	:a v= 0
	if false
		assertFail ." if shouldn't have been called
	elsif true
		:a = 2
	else
		:a = 3
	2 assert=? a
	// else is run
	:a v= 0
	if false
		assertFail ." if shouldn't have been called
	elsif false
		assertFail ." elsif shouldn't have been called
	else
		:a = 3
	3 assert=? a


//
// loop

:while @unittest func()
	:total v= 0
	:i v= 0
	while .` i !=? 5
		:i = i + 1
		:total = total + i
	5  assert=? i
	15 assert=? total

:for @unittest func()
	// todo: should be able to declare i inside for
	:total v= 0
	:i v= 0
	for .[ ` :i = 0 ` ` i !=? 5 ` ` :i = i + 1 `
		:total = total + i
	10 assert=? total

:forEach @unittest func()
	// loop thru array
	:total v= 0
	:i forEach ( 1 .. 5 )
		:total = total + i
	15 assert=? total
	// loop thru map
	:total v= 0
	:i forEach { :a 2 :b 4 }
		:total = total + i . 1
	6 assert=? total
	// pattern match against map
	:str v= ""
	:total v= 0
	[ :key :value ] forEach { :a 2 :b 4 }
		:str = str + key
		:total = total + value
	:ab assert=? str
	6 assert=? total

:forEachDelim @unittest func()
	// create a function that turns a body into a map
	:thing v= func()
		:result v= nil
		:map forEachDelim [ body :{ ]
			:result = result + map
	:thing @body? true
	// use that function to create a map
	:test v= thing
		:a 5
		:b 7
	{ :a 5 :b 7 } assert=? test

:break @unittest func()
	:total v= 0
	:i v= 0
	while .` i !=? 8
		:i = i + 1
		if i =? 4
			break
		:total = total + i
	6 assert=? total


//
// iterators

:=eachIn @unittest func()
	// test array iterator
	:total v= 0
	:i =eachIn [ 4 1 3 6 10 ]
		:total = total + i
	24 assert=? total
	
	// test iterator over two arrays
	:str v= ""
	[ :i :j ] =eachIn [ [ 3 4 ] [ 5 6 7 ] ]
		:str = str + .( ( i =>str ) + " , " + ( j =>str ) + " - "
	" 3,5-3,6-3,7-4,5-4,6-4,7- " assert=? str
	
	// test over a map
	[ :str :total ] v= [ "" 0 ]
	:i =eachIn { :a 2 :b 3 :c 2.5 }
		:str = str + i . 0
		:total = total + i . 1
	:abc assert=? str
	7.5 assert=? total
	
	// test over functions & overloads
	:functions v= func ( ->a @@type :array )
		1
	:count v= 0
	:i =eachIn ( functions )
		:count = count + 1
	1 assert=? count
	:functions f= func ( ->a @@type :map )
		2
	:count v= 0
	:i =eachIn ( functions )
		:count = count + 1
	2 assert=? count
	
	// test function body
	:testFunc v= func()
		one line
		second line
	:count v= 0
	:i =eachIn ( l3.getFunctionBody { :key :testFunc } )
		:count = count + ( i .size )   // count words
	4 assert=? count

// see the :eachIn test
:iterator @unittest stubFunc


//
// strings

:=>str @unittest func()
	:5				assert=? 5 =>str
	:5.5			assert=? 5.5 =>str
	:5				assert=? :5 =>str
	" [ 1 2 3 ] "	assert=? [ 1 2 3 ] =>str

:+ @unittest func()
	:qwert assert=? :qw + :ert

:"" @unittest func()
	:string	assert=? l3.getType .{ :value ""
	0		assert=? l3.getCount ""

:""" @unittest func()
	:a v= """
		this is
		some multiline
		text
	" this is some multiline text " assert=? a

:\n @unittest stubFunc

:\s @unittest stubFunc

:\t @unittest stubFunc


//
// enumerated type

:=enum @unittest func()
	:asdf =enum [ :qwert :yuiop ]
	0		assert=? asdf.qwert
	1		assert=? asdf.yuiop
	:asdf	assert=? l3.getType .{ :value asdf.yuiop


//
// math

:+ @unittest func()
	42 assert=? 39 + 3

:- @unittest func()
	7 assert=? 10 - 3

:* @unittest func()
	10 assert=? 5 * 2

:/ @unittest func()
	3 assert=? 9 / 3

:% @unittest func()
	3 assert=? 15 % 4

:sqrt @unittest func()
	assertTrue? ( ( sqrt 4 ) - 2 ) <? 0.00000001
	assertTrue? ( ( sqrt 2 ) - 1.414213562 ) <? 0.00000001

:<? @unittest func()
	assertFalse? 4 <? 4
	assertTrue?  4 <? 5
	assertFalse? 5 <? 4

:<=? @unittest func()
	assertTrue?  4 <=? 4
	assertTrue?  4 <=? 5
	assertFalse? 5 <=? 4

:>? @unittest func()
	assertFalse? 4 >? 4
	assertTrue?  5 >? 4
	assertFalse? 4 >? 5

:>=? @unittest func()
	assertTrue?  4 >=? 4
	assertTrue?  5 >=? 4
	assertFalse? 4 >=? 5

:min @unittest func()
	4 assert=? 4 min 7

:max @unittest func()
	7 assert=? 4 max 7


//
// modules

:import @unittest func()
	assertTrue?  import :../../l3/module.l3
	assertFalse? import :../../l3/module.l3

:reimport @unittest func()
	assertTrue?  reimport :../../l3/module.l3
	assertTrue?  reimport :../../l3/module.l3


//
// I/O

:print @unittest func()
	false
