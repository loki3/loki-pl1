// unittests for bootstrap.l3

:(		@unittest func()
	14 assert=? ( 4 + 3 ) * 2
	10 assert=? 4 + ( 3 * 2 )

:[		@unittest func()
	:array assert=? l3.getType { :value [ 1 2 ] }
	4 assert=? l3.getCount [ 3 4 5 6 ]

:{		@unittest func()
	:map assert=? l3.getType { :value { :a 1 :b 2 } }
	2 assert=? l3.getCount { :a 1 :b 2 }

://		@unittest func()
	// assertTrue? false
	true

:///func @unittest func()
	///func
		this should all be ignored
		as well as this line
			and this
		and this
	true

:///	@unittest func()
	/// this should all be ignored
		as well as this line
			and this
		and this
	true

:`		@unittest func()
	8 assert=? l3.eval ` 5 + 3 `

:.(		@unittest func()
	10 assert=? 4 + .( 3 * 2

:.[		@unittest func()
	3 assert=? l3.getCount .[ 2 3 4

:.{		@unittest func()
	:map assert=? l3.getType .{ :value .{ :a 1 :b 2 

:.`		@unittest func()
	8 assert=? l3.eval .` 5 + 3

:/*		@unittest func()
	:a /* comment */ v= /* comment */ 5 + 3
	8 assert=? a

:"		@unittest func()
	:asdf assert=? " asdf "

:'		@unittest func()
	:asdf assert=? ' asdf '

:."		@unittest func()
	:asdf assert=? ." asdf

:.'		@unittest func()
	:asdf assert=? .' asdf

:v=		@unittest func()
	:a v= 5
	5 assert=? a

:f=		@unittest func()
	// try overloads on different numbers of parameters
	:f f= .(( :a ` a + 1 `
	5 assert=? f 4
	:f f= .(( [ :a :b :c ] ` a + b + c `
	5 assert=? f 4
	9 assert=? f .[ 4 2 3
	:f f= .(( [ :a :b ] ` a * b `
	5 assert=? f 4
	8 assert=? f .[ 4 2
	9 assert=? f .[ 4 2 3
	
	// try overloads based on type
	// general
	:g f= .(( :a ` a + 1 `
	5 assert=? g 4
	// most specific
	:g f= .(( ( :a : :float ) ` a + 3 `
	5 assert=? g 4
	7 assert=? g 4.0
	// intermediate
	:g f= .(( ( :a : :number ) ` a + 2 `
	6 assert=? g 4
	7 assert=? g 4.0

:=		@unittest func()
	:a v= 5
	:a = 4
	4 assert=? a

:var	@unittest func()
	var :a = 5
	5 assert=? a


//
// function definitions:

:func	@unittest func()
	:a v= func ->b
		b + 2
	7 assert=? a 5

:infix	@unittest func()
	:a v= .( ->b infix ->c
		b + c
	42 assert=? 40 a 2

:postfix @unittest func()
	:a v= .( ->b postfix
		b + 2
	5 assert=? 3 a

:func()	@unittest func()
	:a v= func()
		3.5
	3.5 assert=? a


//
// get & set

:.		@unittest func()
	4 assert=? { :a 3 :b 4 :c 5 } . :b
	3 assert=? [ 6 5 4 3 2 ] . 3
	// map default
	:a v= { :a 9 :b 12 } d= 42
	12 assert=? a . :b
	42 assert=? a . :notThere
	// array default
	:b v= [ 200 400 ] d= 314
	200 assert=? b . 0
	400 assert=? b . 1
	314 assert=? b . 2
	314 assert=? b . -1

:@		@unittest func()
	:a v= 1
	:a @ [ :blah :something ]
	:something assert=? ( l3.getMetadata { :key :a } ) . :blah

:.@		@unittest func()
	:a v= 1
	:a @ [ :blah :something ]
	:something assert=? :a .@ :blah

:.@@	@unittest func()
	:a v= 1
	:a @ [ :blah :something ]
	{ :blah :something } assert=? :a .@@

:@doc	@unittest func()
	:a v= 1
	:a @doc :whatever
	:whatever assert=? :a .@doc

:.@doc	@unittest func()
	:a v= 1.5
	:a @doc :whatever
	:whatever assert=? :a .@doc

:@cat	@unittest func()
	:a v= 1
	:a @cat :something
	:something assert=? :a .@cat

:.@cat	@unittest func()
	:a v= 1.5
	:a @cat :something
	:something assert=? :a .@cat

:@order @unittest func()
	:a v= (| ## + 2 |)
	// a should be applied after *
	:a @order 5
	12 assert=? a 5 * 2
	// a should be applied before *
	:a @order 1
	14 assert=? a 5 * 2

:@body? @unittest func()
	:a v= func()
		:result v= nil
		:line forEach body
			:result = result + [ line ]
	:a @body? true
	:b v= a
		3
		4
	[ 3 4 ] assert=? b

:@type @unittest func()
	:a v= 1
	:a @type :int
	:int assert=? :a .@ :l3.value.type

:@iterator @unittest func()
	:a v= (| ## + 1 |)
	:a @iterator
	:iterator assert=? :a .@ :l3.value.type

:@@ @unittest func()
	:a v= 1
	a @@ [ :key 2 ]
	2 assert=? :a .@ :key

:: @unittest func()
	:a v= 1
	a : :int
	:int assert=? :a .@ :l3.pattern.type

:d= @unittest func()
	:a v= 1
	a d= 2
	2 assert=? :a .@ :l3.pattern.default

:... @unittest func()
	:a v= 1
	a ...
	true assert=? :a .@ :l3.pattern.rest

:@@hasKeys @unittest func()
	:a v= 1
	a @@hasKeys [ :b :c ]
	[ :b :c ] assert=? :a .@ :l3.pattern.hasKeys

:copy	@unittest func()
	:a v= 1
	1 assert=? copy a
	:str assert=? copy :str

:currentScope @unittest func()
	// create accumulator outside the nested scope
	:map v= { }
	if true
		// add some vars in this scope to examine
		:a v= 1
		:b v= 2
		var :i forEach currentScope
			// ignore vars that the forEach created
			if ( ( i . 0 ) =? :a |? ( i . 0 ) =? :b )
				:map = map + { ( i . 0 ) ( i . 1 ) }
	{ :a 1 :b 2 } assert=? map

:setScopeName @unittest noTestNeeded

:closure @unittest func()
	:value v= 1
	
	// not using a closure
	// returns a function that adds onto 'value'
	:nested v= func ->value
		:add v= func ->plus
			value + plus
		add
	// 2 gets lost, instead it'll add onto 1
	:getValue v= nested 2
	4 assert=? getValue 3
	
	// create a closure
	:nested2 v= func ->value
		:add v= func ->plus
			value + plus
		closure :add
	// this time it'll add onto 2
	:getValue v= nested2 2
	5 assert=? getValue 3

:i= @unittest func()
	[ :a :b ] i= [ 4 5 ]
	4 assert=? a
	5 assert=? b
	[ :c :b ] i= [ 9 22 ]
	5 assert=? b
	9 assert=? c
	// make sure nested scope doesn't use outter scope
	:val v= 1
	if true
		1 assert=? val
		:val i= 2
		2 assert=? val
	1 assert=? val


//
// more function definitions

:lambda	@unittest func()
	:2+ v= .( lambda .[ :x .` 2 + x
	3 assert=? 2+ 1

:((		@unittest func()
	:2+ v= (( :x ` 2 + x ` ))
	3 assert=? 2+ 1
	:mult v= (( [ :a :b ] ` a * b ` ))
	12 assert=? mult [ 6 2 ]

:.((	@unittest func()
	:2+ v= .(( :x ` 2 + x `
	3 assert=? 2+ 1

:lambda1	@unittest func()
	:2+ v= .( lambda1 .` ## + 2
	3 assert=? 2+ 1

:(|		@unittest func()
	:2+ v= (| ## + 2 |)
	3 assert=? 2+ 1

:.(|	@unittest func()
	:2+ v= .(| ## + 2
	3 assert=? 2+ 1

:lambda2	@unittest func()
	:div v= .( lambda2 ` #1 / #2 `
	3 assert=? 6 div 2

:(<		@unittest func()
	:div v= (< #1 / #2 >)
	3 assert=? 6 div 2

:.(<	@unittest func()
	:div v= .(< #1 / #2
	3 assert=? 6 div 2


//
// types

:_ @unittest func()
	nil assert=? _
	// _ in pattern matching means ignore the value
	[ :a _ :b ] v= [ 3 5 7 ]
	3 assert=? a
	7 assert=? b


//
// debugging

:repl @unittest noTestNeeded


//
// logic

:&? @unittest func()
	assertTrue?  true  &? true
	assertFalse? true  &? false
	assertFalse? false &? true
	assertFalse? false &? false

:|? @unittest func()
	assertTrue?  true  |? true
	assertTrue?  true  |? false
	assertTrue?  false |? true
	assertFalse? false |? false

:!? @unittest func()
	assertTrue?  !? false
	assertFalse? !? true

:=? @unittest func()
	assertTrue?  5 =? 5
	assertFalse? 5 =? 4

:!=? @unittest func()
	assertTrue?  5 !=? 4
	assertFalse? 5 !=? 5

:=any? @unittest func()
	assertTrue?  5 =any? [ 3 5 6 9 ]
	assertFalse? 4 =any? [ 3 5 6 9 ]


//
// arrays

:.. @unittest func()
	[ 3 4 5 6 ] assert=? ( 3 .. 6 )

:+ @unittest func()
	[ 3 4 5 6 ] assert=? [ 3 4 ] + [ 5 6 ]
	[ 3 4 5 6 ] assert=? [ 3 4 5 ] + 6
	[ 3 4 5 6 ] assert=? [ 3 4 5 6 ] + [ ]
	[ 3 4 5 6 ] assert=? [ 3 4 5 6 ] + nil

:+= @unittest func()
	// array addition
	:a v= [ 3 4 5 ]
	// todo: perhaps it should be :a += 6
	a += 6
	[ 3 4 5 6 ] assert=? a

:.size @unittest func()
	3 assert=? [ 5 6 8 ] .size
	2 assert=? { :a 1 :b 3 } .size
	5 assert=? " qwert " .size

:apply @unittest func()
	[ 6 10 14 ] assert=? [ 3 5 7 ] apply (| ## * 2 |)

:foldLeft @unittest func()
	1 assert=? [ 27 9 3 ] foldLeft (< #1 / #2 >)

:foldRight @unittest func()
	9 assert=? [ 27 9 3 ] foldRight (< #1 / #2 >)

:filter @unittest func()
	// only take the odd values
	[ 3 5 7 ] assert=? [ 2 3 5 6 7 8 ] filter (| ## % 2 =? 1 |)
	// take every other value
	[ 3 6 8 ] assert=? [ 2 3 5 6 7 8 ] filter (< #1 % 2 =? 1 >)

:makeArray @unittest func()
	:a v= makeArray
		:asdf
		3.5
		2
	[ :asdf 3.5 2 ] assert=? a

:by @unittest func()
	[ 2 6 11 ] assert=? [ 2 3 5 6 7 8 11 ] by 3


//
// maps

:makeMap @unittest func()
	:a v= makeMap
		:1 2
		:3 4
	{ :1 2 :3 4 } assert=? a

:applyMap @unittest func()
	{ :a 42 :b 17 } assert=? { :a 84 :b 34 } applyMap (| ## / 2 |)

:filterMap @unittest func()
	{ :b 2 :d 6 } assert=? { :a 1 :b 2 :c 3 :d 6 } filterMap (| ## % 2 =? 0 |)
	{ :c 3 }      assert=? { :a 1 :b 2 :c 3 :d 6 } filterMap (< #1 =? :c >)

:mapToArray @unittest func()
	[ 42 17 ] assert=? { :a 84 :b 34 } mapToArray (| ## / 2 |)
	[ ] assert=? { } mapToArray (| ## / 2 |)

:filterMapToArray @unittest func()
	[ 2 6 ] assert=? { :a 1 :b 2 :c 3 :d 6 } filterMapToArray (| ## % 2 =? 0 |)
	[ 3 ]   assert=? { :a 1 :b 2 :c 3 :d 6 } filterMapToArray (< #1 =? :c >)


//
// conditional

:? @unittest func()
	2 assert=? true  ? [ 2 3 ]
	3 assert=? false ? [ 2 3 ]

:if @unittest func()
	// if is run
	:a v= false
	if true
		:a = true
	assertTrue? a
	// if is skipped
	if false
		assertFail ." if shouldn't have been called

:elsif @unittest func()
	// if is run, not elsif
	:a v= 0
	if true
		:a = 1
	elsif true
		assertFail ." elsif shouldn't have been called
	1 assert=? a
	// elsif is run
	:a v= 0
	if false
		assertFail ." if shouldn't have been called
	elsif true
		:a = 2
	2 assert=? a
	// if & elsif are skipped
	:a v= 0
	if false
		assertFail ." if shouldn't have been called
	elsif false
		assertFail ." elsif shouldn't have been called
	0 assert=? a

:else @unittest func()
	// if is run, not else
	:a v= 0
	if true
		:a = 1
	else
		assertFail ." else shouldn't have been called
	1 assert=? a
	// else is run
	:a v= 0
	if false
		assertFail ." if shouldn't have been called
	else
		:a = 2
	2 assert=? a
	
	// if is run
	:a v= 0
	if true
		:a = 1
	elsif true
		assertFail ." elsif shouldn't have been called
	else
		assertFail ." else shouldn't have been called
	1 assert=? a
	// elsif is run
	:a v= 0
	if false
		assertFail ." if shouldn't have been called
	elsif true
		:a = 2
	else
		:a = 3
	2 assert=? a
	// else is run
	:a v= 0
	if false
		assertFail ." if shouldn't have been called
	elsif false
		assertFail ." elsif shouldn't have been called
	else
		:a = 3
	3 assert=? a

:match @unittest func()
	:test v= func ->pattern
		var :result
		match pattern
			when [ ( ->a : :int ) 1 ]
				:result = a + 1
			when [ ( ->a : :int ) 2 ]
				:result = a + 2
			when [ ( ->a : :int ) 3 ]
				:result = 3
			when { :a ( ->b : :int ) }
				:result = b + 4
			default
				:result = 4
		result
	5 assert=? test [ 4 1 ]
	6 assert=? test [ 4 2 ]
	3 assert=? test [ 5 3 ]
	9 assert=? test { :a 5 }
	// these all fall through to the default
	4 assert=? test [ 6 4 ]
	4 assert=? test { :a 5 :b 6 }
	4 assert=? test { :a :blah }
	true
	
	:simple v= func ->input
		var :result
		match input
			when 1
				:result = :one
			when 2
				:result = :two
			default
				:result = :default
		result
	:one     assert=? simple 1
	:two     assert=? simple 2
	:default assert=? simple { :a 3 :b 4 }

:when @unittest noTestNeeded

:default @unittest noTestNeeded

:if!nil @unittest func()
	5   assert=? .( 1   if!nil 5
	nil assert=? .( nil if!nil 5

:do!nil @unittest func()
	[ :a :final ] v= [ 0 0 ]
	do!nil ` a `
		:final = 1
		:final = 2
		:a = nil
		:final = 3
	2 assert=? final


//
// loop

:while @unittest func()
	:total v= 0
	:i v= 0
	while .` i !=? 5
		:i = i + 1
		:total = total + i
	5  assert=? i
	15 assert=? total

:repeat @unittest func()
	:total v= 0
	repeat 5
		:total = total + 2
	10 assert=? total

:repeatsOf @unittest func()
	:total v= 0
	5 repeatsOf .` :total = total + 2
	10 assert=? total

:for @unittest func()
	// todo: should be able to declare i inside for
	:total v= 0
	:i v= 0
	for .[ ` :i = 0 ` ` i !=? 5 ` ` :i = i + 1 `
		:total = total + i
	10 assert=? total

:forEach @unittest func()
	// loop thru array
	:total v= 0
	:i forEach ( 1 .. 5 )
		:total = total + i
	15 assert=? total
	// loop thru map
	:total v= 0
	:i forEach { :a 2 :b 4 }
		:total = total + i . 1
	6 assert=? total
	// pattern match against map
	:str v= ""
	:total v= 0
	[ :key :value ] forEach { :a 2 :b 4 }
		:str = str + key
		:total = total + value
	:ab assert=? str
	6 assert=? total
	// each time through loop should be new scope
	:i forEach ( 1 .. 3 )
		nil assert=? .( l3.getValue .{ :key :doesn'tExist
		:doesn'tExist v= 5

:forEachDelim @unittest func()
	// create a function that turns a body into a map
	:thing v= func()
		:result v= nil
		:map forEachDelim [ body :{ ]
			:result = result + map
	:thing @body? true
	// use that function to create a map
	:test v= thing
		:a 5
		:b 7
	{ :a 5 :b 7 } assert=? test

:break @unittest func()
	:total v= 0
	:i v= 0
	while .` i !=? 8
		:i = i + 1
		if i =? 4
			break
		:total = total + i
	6 assert=? total


//
// iterators

:=eachIn @unittest func()
	// test array iterator
	:total v= 0
	:i =eachIn [ 4 1 3 6 10 ]
		:total = total + i
	24 assert=? total
	
	// test iterator over two arrays
	:str v= ""
	[ :i :j ] =eachIn [ [ 3 4 ] [ 5 6 7 ] ]
		:str = str + .( ( i =>str ) + " , " + ( j =>str ) + " - "
	" 3,5-3,6-3,7-4,5-4,6-4,7- " assert=? str
	
	// test over a map
	[ :str :total ] v= [ "" 0 ]
	:i =eachIn { :a 2 :b 3 :c 2.5 }
		:str = str + i . 0
		:total = total + i . 1
	:abc assert=? str
	7.5 assert=? total
	
	// test over functions & overloads
	:functions v= func ( ->a : :array )
		1
	:count v= 0
	:i =eachIn ( functions )
		:count = count + 1
	1 assert=? count
	:functions f= func ( ->a : :map )
		2
	:count v= 0
	:i =eachIn ( functions )
		:count = count + 1
	2 assert=? count
	
	// test function body
	:testFunc v= func()
		one line
		second line
	:count v= 0
	:i =eachIn ( l3.getFunctionBody { :key :testFunc } )
		:count = count + ( i .size )   // count words
	4 assert=? count
	
	// each time through loop should be new scope
	:i =eachIn ( 1 .. 3 )
		nil assert=? .( l3.getValue .{ :key :doesn'tExist
		:doesn'tExist v= 5
	true

// see the :eachIn test
:iterator @unittest noTestNeeded


//
// strings

:=>str @unittest func()
	:5				assert=? 5 =>str
	:5.5			assert=? 5.5 =>str
	:5				assert=? :5 =>str
	" [ 1 2 3 ] "	assert=? [ 1 2 3 ] =>str

:$ @unittest func()
	:5 assert=? $ 5

:$_ @unittest func()
	( \s + :5 ) assert=? $_ 5

:$__ @unittest func()
	( \t + :5 ) assert=? $__ 5

:+ @unittest func()
	:qwert assert=? :qw + :ert

:"" @unittest func()
	:string	assert=? l3.getType .{ :value ""
	0		assert=? l3.getCount ""

:""" @unittest func()
	:a v= """
		this is
		some multiline
		text
	" this is some multiline text " assert=? a

:"[ @unittest func()
	:asdf12.34 assert=? "[ :asdf 1 2.34 ]
	:123 assert=? "[ 1 2 3 ]

:."[ @unittest func()
	:asdf12.34 assert=? ."[ :asdf 1 2.34

:\n @unittest noTestNeeded

:\s @unittest noTestNeeded

:\t @unittest noTestNeeded


//
// enumerated type

:=enum @unittest func()
	:asdf =enum [ :qwert :yuiop ]
	0		assert=? asdf.qwert
	1		assert=? asdf.yuiop
	:asdf	assert=? l3.getType .{ :value asdf.yuiop


//
// math

:+ @unittest func()
	42 assert=? 39 + 3

:- @unittest func()
	7 assert=? 10 - 3

:* @unittest func()
	10 assert=? 5 * 2

:/ @unittest func()
	3 assert=? 9 / 3

:% @unittest func()
	3 assert=? 15 % 4

:sqrt @unittest func()
	assertTrue? ( ( sqrt 4 ) - 2 ) <? 0.00000001
	assertTrue? ( ( sqrt 2 ) - 1.414213562 ) <? 0.00000001

:<? @unittest func()
	assertFalse? 4 <? 4
	assertTrue?  4 <? 5
	assertFalse? 5 <? 4

:<=? @unittest func()
	assertTrue?  4 <=? 4
	assertTrue?  4 <=? 5
	assertFalse? 5 <=? 4

:>? @unittest func()
	assertFalse? 4 >? 4
	assertTrue?  5 >? 4
	assertFalse? 4 >? 5

:>=? @unittest func()
	assertTrue?  4 >=? 4
	assertTrue?  5 >=? 4
	assertFalse? 4 >=? 5

:min @unittest func()
	4 assert=? 4 min 7

:max @unittest func()
	7 assert=? 4 max 7


//
// exceptions

:try @unittest noTestNeeded

:catch @unittest func()
	// catch a badToken exception
	:correct v= false
	try
		doesn'tExist
		assertFail ." exception should be thrown before we get here
	catch [ ->a ( ->x ... ) ]
		assertFail ." exception mismatch, so we shouldn't get here
	catch [ ->l3.error.badToken ( ->x ... ) ]
		:correct = true
		:doesn'tExist assert=? l3.error.badToken
	catch :e
		assertFail ." exception should have been caught earlier
	endTry
	assertTrue? correct
	
	// catch an explicitly thrown exception
	:correct v= false
	try
		l3.throw { :a 5 :b 6 }
		assertFail ." exception should be thrown before we get here
	catch [ ->a ( ->x ... ) ]
		:correct = true
		5 assert=? a
	catch [ ->l3.error.badToken ( ->x ... ) ]
		assertFail ." exception should have been caught earlier
	catch :e
		assertFail ." exception should have been caught earlier
	endTry
	assertTrue? correct
	
	// no exception thrown
	try
		true
		true
	catch [ ->a ( ->x ... ) ]
		assertFail ." no exception should be thrown or caught
	catch [ ->l3.error.badToken ( ->x ... ) ]
		assertFail ." no exception should be thrown or caught
	catch :e
		assertFail ." no exception should be thrown or caught
	endTry

:endTry @unittest func()
	if false
		:correct v= false
		try
			true
			try
				doesn'tExist
			// exception wasn't caught, so this'll rethrow it
			endTry
		catch :e
			:correct = true
		endTry
		assertTrue? correct
	true

:rethrow @unittest func()
	if false
		[ :rethrew? :caught? ] v= [ false false ]
		try
			true
			try
				doesn'tExist
			catch :e
				// explicitly rethrow to outside scope
				:rethrew? = true
				rethrow
			endTry
		catch :e
			:caught? = true
		endTry
		assertTrue? rethrew?
		assertTrue? caught?
	true


//
// modules

:import @unittest func()
	assertTrue?  import :../../l3/module.l3
	assertFalse? import :../../l3/module.l3

:reimport @unittest func()
	assertTrue?  reimport :../../l3/module.l3
	assertTrue?  reimport :../../l3/module.l3


//
// I/O

:print @unittest func()
	false


//
// classes

:public @unittest func()
	// a function which creates a 'class'
	// with a constructor, private data, and public methods
	:keepAdding v= func ->initial
		// private variable
		:total v= initial
		
		// methods
		:add v= func ->amount
			:total = total + amount
		:current v= func()
			total
		
		// make methods public
		public
			:add
			:current
	
	:test v= keepAdding 5
	6 assert=? test . :add 1
	6 assert=? test . :current
	8 assert=? test . :add 2
	8 assert=? test . :current
	
	// using composition to extend the class
	:addOrSubtract v= func ->initial
		:base v= keepAdding initial
		
		// additional method
		:subtract v= func ->amount
			base . :add ( 0 - amount )
		
		// expose composed methods & extension
		public
			base
			:subtract
	
	:test v= addOrSubtract 100
	101 assert=? test . :add 1
	101 assert=? test . :current
	91  assert=? test . :subtract 10
	91  assert=? test . :current
