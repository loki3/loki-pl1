
var :fizzBuzz1 = [ ]
var :i forEach ( 1 .. 20 )
	if ( i % 15 =? 0 )
		fizzBuzz1 += ." fizzbuzz
	elsif .( i % 3 =? 0
		fizzBuzz1 += ." fizz
	elsif .( i % 5 =? 0
		fizzBuzz1 += ." buzz
	else
		fizzBuzz1 += i
:fizzBuzz1 @doc ." fizzbuzz using a simple loop

var :fizzBuzz2 = [ ]
var :i forEach ( 1 .. 20 )
	[ :str1 :fizz? ] v= ( i % 3 =? 0 ) ? .[ [ :fizz true ] [ " " false ]
	[ :str2 :buzz? ] v= ( i % 5 =? 0 ) ? .[ [ :buzz true ] [ " " false ]
	fizzBuzz2 += .( ( fizz? |? buzz? ) ? .[ ( str1 + str2 ) i
:fizzBuzz2 @doc ." fizzbuzz using multiple return values

var :fizzbuzz3 = func0
	var :zzz = [ ]
	var :i forEach ( 1 .. 20 )
		if ( i % 15 =? 0 )
			zzz += ." fizzbuzz
		elsif .( i % 3 =? 0
			zzz += ." fizz
		elsif .( i % 5 =? 0
			zzz += ." buzz
		else
			zzz += i
	zzz
:fizzbuzz3 @doc ." fizzbuzz using a function in a simple loop


//
// complex numbers

:i v= .( ->y 1func
	{ :x 0 :y y }
:i @order 1
:i @doc ." Creates a complex number

:+ f= ( { :x ->x1 :y ->y1 } 1func1 { :x ->x2 :y ->y2 } )
	{ :x ( x1 + x2 ) :y ( y1 + y2 ) }
:+ f= ( { :x ->x1 :y ->y1 } 1func1 ( ->x2 : :number ) )
	{ :x ( x1 + x2 ) :y y1 }
:+ f= ( ( ->x1 : :number ) 1func1 { :x ->x2 :y ->y2 } )
	{ :x ( x1 + x2 ) :y y2 }
:+ @doc ." Adds together two complex numbers of the form { :x # :y # }

:* f= ( { :x ->x1 :y ->y1 } 1func1 { :x ->x2 :y ->y2 } )
	{ :x ( x1 * x2 - y1 * y2 ) :y ( x1 * y2 + x2 * y1 ) }
:* @doc ." Multiples together two complex numbers of the form { :x # :y # }


//
// an enum representing the days of the week

:days =enum .[ :sunday :monday :tuesday :wednesday :thursday :friday :saturday
:days @doc ." an enum representing the days of the week

:isWeekend v= func1 ( ->day : :days )
	( day =? days.sunday ) |? ( day =? days.saturday )
:isWeekend @doc ." true if the day is Saturday or Sunday


//
// a mechanism for defining a function recursively but having it execute iteratively

:repeat v= func1 [ ->a ->f ]
	while ` nil !=? f `
		[ :a :f ] = f [ a ]
	a
:repeat @doc """
	Turns a recursive function into an interative loop.
	The passed function must take an iteration value and a result value
	and return a new result and a partial function bound to the next
	iteration value but still requiring the result value.
	When the computation is finished, the returned function should be nil.

:! v= .( ->n 1func
	:fact v= func1 [ ->a ->b ]
		( a >? 0 ) ? .[ [ ( a * b ) ( fact [ ( a - 1 ) ] ) ]  [ b nil ]
	repeat [ 1 ( fact [ n ] ) ]
:! @order 2
:! @doc ." Factorial operator defined recursively but executed iteratively


// simple factorial
:!2 v= ( ->n 1func )
	( n <? 1 ) ? .[ 1 .` ( 1 .. n ) fold (< #1 * #2 >)
:!2 @doc ." Factorial operator using a functional pattern


//
// Fibonacci numbers

:fib1 v= func1 ->n
	[ :f1 :f2 ] v= [ 1 1 ]
	if n >? 1
		:i forEach ( 2 .. n )
			[ :f1 :f2 ] = [ f2 ( f1 + f2 ) ]
	f2
:fib1 @doc ." Iterative computation of Fibonacci numbers

:fib2 v= func1 ->n
	:sub v= func1 .[ ->f1 ->f2 ->i
		( i =? n ) ? .[ f2 .` sub .[ f2 ( f1 + f2 ) ( i + 1 )
	sub .[ 0 1 0
:fib2 @doc ." Recursive computation of Fibonacci numbers


//
// Units

:unitsType =enum [ :distance :weight ]
:unitsType @doc ." A list of the different types of supported units


:mm v= .( ( ->x : :number ) 1func
	{ :meters ( x / 1000.0 ) :units unitsType.distance }
:mm @order 1 @doc ." Used to specify a particular number of millimeters

:m  v= .( ( ->x : :number ) 1func
	{ :meters x :units unitsType.distance }
:m  @order 1 @doc ." Used to specify a particular number of meters

:in v= .( ( ->x : :number ) 1func
	{ :meters ( x * 0.0254 ) :units unitsType.distance }
:in @order 1 @doc ." Used to specify a particular number of inches

:ft v= .( ( ->x : :number ) 1func
	{ :meters ( x * 0.3048 ) :units unitsType.distance }
:ft @order 1 @doc ." Used to specify a particular number of feet


:=>mm v= .( { :meters ->meters :units unitsType.distance } 1func
	meters * 1000
:=>mm @doc ." Convert a distance into millimeters

:=>m  v= .( { :meters ->meters :units unitsType.distance } 1func
	meters
:=>m  @doc ." Convert a distance into meters

:=>in v= .( { :meters ->meters :units unitsType.distance } 1func
	meters / 0.0254
:=>in @doc ." Convert a distance into inches

:=>ft v= .( { :meters ->meters :units unitsType.distance } 1func
	meters / 0.3048
:=>ft @doc ." Convert a distance into feet


:+ f= .( { :meters ->x :units unitsType.distance } 1func1 { :meters ->y :units unitsType.distance }
	{ :meters ( x + y ) :units unitsType.distance }

:- f= .( { :meters ->x :units unitsType.distance } 1func1 { :meters ->y :units unitsType.distance }
	{ :meters ( x - y ) :units unitsType.distance }


:g  v= .( ( ->x : :number ) 1func
	{ :grams x :units unitsType.weight }
:g  @order 1 @doc ." Used to specify a particular number of grams

:kg v= .( ( ->x : :number ) 1func
	{ :grams ( x * 1000 ) :units unitsType.weight }
:kg @order 1 @doc ." Used to specify a particular number of kilograms

:oz v= .( ( ->x : :number ) 1func
	{ :grams ( x * 28.349523125 ) :units unitsType.weight }
:oz @order 1 @doc ." Used to specify a particular number of ounces

:lb v= .( ( ->x : :number ) 1func
	{ :grams ( x * 453.59237 ) :units unitsType.weight }
:lb @order 1 @doc ." Used to specify a particular number of pounds


:=>g  v= .( { :grams ->x :units unitsType.weight } 1func
	x
:=>g @doc ." Convert a weight into grams

:=>kg v= .( { :grams ->x :units unitsType.weight } 1func
	x / 1000.0
:=>kg @doc ." Convert a weight into kilograms

:=>oz v= .( { :grams ->x :units unitsType.weight } 1func
	x / 28.349523125
:=>oz @doc ." Convert a weight into ounces

:=>lb v= .( { :grams ->x :units unitsType.weight } 1func
	x / 453.59237
:=>lb @doc ." Convert a weight into pounds


:+ f= .( { :grams ->x :units unitsType.weight } 1func1 { :grams ->y :units unitsType.weight }
	{ :grams ( x + y ) :units unitsType.weight }

:- f= .( { :grams ->x :units unitsType.weight } 1func1 { :grams ->y :units unitsType.weight }
	{ :grams ( x - y ) :units unitsType.weight }
