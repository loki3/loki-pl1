
var :fizzBuzz1 = [ ]
var :i forEach ( 1 .. 20 )
	if ( i % 15 =? 0 )
		fizzBuzz1 += ." fizzbuzz
	elsif .( i % 3 =? 0
		fizzBuzz1 += ." fizz
	elsif .( i % 5 =? 0
		fizzBuzz1 += ." buzz
	else
		fizzBuzz1 += i
:fizzBuzz1 @doc ." fizzbuzz using a simple loop

var :fizzBuzz2 = [ ]
var :i forEach ( 1 .. 20 )
	[ :str1 :fizz? ] v= ( i % 3 =? 0 ) ? .[ [ :fizz true ] [ " " false ]
	[ :str2 :buzz? ] v= ( i % 5 =? 0 ) ? .[ [ :buzz true ] [ " " false ]
	fizzBuzz2 += .( ( fizz? |? buzz? ) ? .[ ( str1 + str2 ) i
:fizzBuzz2 @doc ." fizzbuzz using multiple return values

var :fizzbuzz3 = func()
	var :zzz = [ ]
	var :i forEach ( 1 .. 20 )
		if ( i % 15 =? 0 )
			zzz += ." fizzbuzz
		elsif .( i % 3 =? 0
			zzz += ." fizz
		elsif .( i % 5 =? 0
			zzz += ." buzz
		else
			zzz += i
	zzz
:fizzbuzz3 @doc ." fizzbuzz using a function in a simple loop


//
// complex numbers

:i v= .( ->y postfix
	{ :x 0 :y y }
:i @order 1
:i @doc ." Creates a complex number

:+ f= ( { :x ->x1 :y ->y1 } infix { :x ->x2 :y ->y2 } )
	{ :x ( x1 + x2 ) :y ( y1 + y2 ) }
:+ f= ( { :x ->x1 :y ->y1 } infix ( ->x2 @@type :number ) )
	{ :x ( x1 + x2 ) :y y1 }
:+ f= ( ( ->x1 @@type :number ) infix { :x ->x2 :y ->y2 } )
	{ :x ( x1 + x2 ) :y y2 }
:+ @doc ." Adds together two complex numbers of the form { :x # :y # }

:* f= ( { :x ->x1 :y ->y1 } infix { :x ->x2 :y ->y2 } )
	{ :x ( x1 * x2 - y1 * y2 ) :y ( x1 * y2 + x2 * y1 ) }
:* @doc ." Multiples together two complex numbers of the form { :x # :y # }


//
// an enum representing the days of the week

:days =enum .[ :sunday :monday :tuesday :wednesday :thursday :friday :saturday
:days @doc ." an enum representing the days of the week

:isWeekend v= func ( ->day @@type :days )
	( day =? days.sunday ) |? ( day =? days.saturday )
:isWeekend @doc ." true if the day is Saturday or Sunday


//
// a mechanism for defining a function recursively but having it execute iteratively

:repeat v= func [ ->a ->f ]
	while ` nil !=? f `
		[ :a :f ] = f [ a ]
	a
:repeat @doc """
	Turns a recursive function into an interative loop.
	The passed function must take an iteration value and a result value
	and return a new result and a partial function bound to the next
	iteration value but still requiring the result value.
	When the computation is finished, the returned function should be nil.

:! v= .( ->n postfix
	:fact v= func [ ->a ->b ]
		( a >? 0 ) ? .[ [ ( a * b ) ( fact [ ( a - 1 ) ] ) ]  [ b nil ]
	repeat [ 1 ( fact [ n ] ) ]
:! @order 2
:! @doc ." Factorial operator defined recursively but executed iteratively


// simple factorial
:!2 v= ( ->n postfix )
	( n <? 1 ) ? .[ 1 .` ( 1 .. n ) fold (< #1 * #2 >)
:!2 @doc ." Factorial operator using a functional pattern


//
// Fibonacci numbers

:fib1 v= func ->n
	[ :f1 :f2 ] v= [ 1 1 ]
	if n >? 1
		:i forEach ( 2 .. n )
			[ :f1 :f2 ] = [ f2 ( f1 + f2 ) ]
	f2
:fib1 @doc ." Iterative computation of Fibonacci numbers

:fib2 v= func ->n
	:sub v= func .[ ->f1 ->f2 ->i
		( i =? n ) ? .[ f2 .` sub .[ f2 ( f1 + f2 ) ( i + 1 )
	sub .[ 0 1 0
:fib2 @doc ." Recursive computation of Fibonacci numbers
